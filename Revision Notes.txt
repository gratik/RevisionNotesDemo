===============================================================================
COMPREHENSIVE C# AND OOP REVISION NOTES
===============================================================================
Subject: C#, Object-Oriented Programming, Design Patterns, and .NET Framework
Author: Barry Compuesto
Date: 14/02/2026
Version: 3.0 - Complete Edition with Comprehensive Documentation

This document serves as a complete reference for C# development, OOP principles,
design patterns, memory management, async programming, and .NET framework concepts.

Reference Project: RevisionNotesDemo
Location: c:\Users\barry\OneDrive\LearningProjects\RevisionNotes\RevisionNotesDemo

This project contains 107+ working code examples demonstrating every concept in
these notes, plus 25 comprehensive documentation guides totaling 18,000+ lines.
All files are fully documented with comprehensive headers.

===============================================================================
TABLE OF CONTENTS
===============================================================================

PART 1: OOP PRINCIPLES (SOLID)
  1.1 Single Responsibility Principle (SRP)
  1.2 Open-Closed Principle (OCP)
  1.3 Liskov Substitution Principle (LSP)
  1.4 Interface Segregation Principle (ISP)
  1.5 Dependency Inversion Principle (DIP)

PART 2: CORE DEVELOPMENT PRINCIPLES
  2.1 KISS (Keep It Simple, Stupid)
  2.2 DRY (Don't Repeat Yourself)
  2.3 YAGNI (You Aren't Gonna Need It)
  2.4 TDA (Tell, Don't Ask)

PART 3: DESIGN PATTERNS - CREATIONAL
  3.1 Singleton Pattern
  3.2 Factory Method Pattern
  3.3 Abstract Factory Pattern
  3.4 Builder Pattern
  3.5 Prototype Pattern

PART 4: DESIGN PATTERNS - STRUCTURAL
  4.1 Adapter Pattern
  4.2 Decorator Pattern
  4.3 Facade Pattern
  4.4 Composite Pattern
  4.5 Proxy Pattern
  4.6 CQRS Pattern
  4.7 Repository Pattern
  4.8 Unit of Work Pattern
  4.9 Flyweight Pattern
  4.10 Bridge Pattern

PART 5: DESIGN PATTERNS - BEHAVIORAL
  5.1 Observer Pattern
  5.2 Strategy Pattern
  5.3 Command Pattern
  5.4 Mediator Pattern
  5.5 State Pattern
  5.6 Chain of Responsibility Pattern
  5.7 Specification Pattern
  5.8 Null Object Pattern
  5.9 Template Method Pattern
  5.10 Visitor Pattern
  5.11 Memento Pattern

PART 6: MEMORY MANAGEMENT
  6.1 Stack vs Heap
  6.2 Garbage Collection
  6.3 Memory Leaks
  6.4 Struct vs Class

PART 7: ASYNC & MULTITHREADING
  7.1 Task vs Thread vs ValueTask
  7.2 async/await Internals
  7.3 Deadlock Prevention
  7.4 Concurrent Collections

PART 8: .NET FRAMEWORK CONCEPTS
  8.1 .NET Evolution
  8.2 Dependency Injection
  8.3 Middleware (ASP.NET Core)
  8.4 IQueryable vs IEnumerable
  8.5 LINQ (Language Integrated Query)
  8.6 Entity Framework Core
      8.6.1 Change Tracking
      8.6.2 Relationships & Navigation Properties
      8.6.3 Migrations in Depth
      8.6.4 Performance Optimization
      8.6.5 Best Practices & Anti-Patterns ⭐ NEW
  8.7 Exception Handling
  8.8 Configuration & Options
  8.9 Logging

PART 9: PRACTICAL PATTERNS & BEST PRACTICES
  9.1 Caching Implementation
  9.2 API Optimization
  9.3 Global Exception Handling
  9.4 Serialization
  9.5 Options Pattern
  9.6 Security Best Practices
  9.7 Performance Optimization

PART 10: COMPREHENSIVE DOCUMENTATION GUIDES
  10.1 OOP Principles Guide (SOLID, KISS, DRY, YAGNI)
  10.2 Core C# Features Guide (Generics, Delegates, Extensions)
  10.3 Modern C# Features Guide (Records, Pattern Matching, Nullable)
  10.4 Design Patterns Guide (26 patterns with examples)
  10.5 Memory Management Guide (Stack/Heap, GC, Disposal)
  10.6 Async & Multithreading Guide (Task, async/await, Deadlocks)
  10.7 LINQ & Queries Guide (IQueryable vs IEnumerable)
  10.8 Advanced C# Guide (Reflection, Attributes, Metadata)
  10.9 Entity Framework Guide (Best Practices, Tracking, N+1)
  10.10 Data Access Guide (EF Core, Dapper, ADO.NET)
  10.11 Testing Guide (xUnit, NUnit, MSTest, Mocking)
  10.12 Logging & Observability Guide (Structured Logging, Correlation)
  10.13 Performance Guide (Span<T>, Benchmarking, Optimization)
  10.14 Security Guide (JWT, OAuth, Encryption, OWASP)
  10.15 Resilience Guide (Polly, Circuit Breaker, Retry)
  10.16 Web API & MVC Guide (Minimal API, Controllers, Middleware)
  10.17 API Documentation Guide (Swagger/OpenAPI, Versioning)
  10.18 Practical Patterns Guide (Caching, Validation, Mapping)
  10.19 Configuration Guide (Options Pattern, Settings, Feature Flags)
  10.20 .NET Concepts Guide (Dependency Injection, Service Lifetimes)
  10.21 Health Checks Guide (Liveness, Readiness, Custom Checks)
  10.22 Real-Time Communication Guide (SignalR, WebSockets, Hubs)
  10.23 Deployment & DevOps Guide (Docker, Kubernetes, CI/CD)
  10.24 Message Architecture Guide (RabbitMQ, Service Bus, Events)
  10.25 Interview Preparation Guide (Questions, Challenges, System Design)
  9.6 Background Services

APPENDIX A: Patterns That Are Overrated Now
APPENDIX B: Quick Reference Tables
APPENDIX C: Common Interview Questions

===============================================================================
PART 1: OOP PRINCIPLES (SOLID)
===============================================================================

The SOLID principles are the foundation of good object-oriented design. They
promote maintainable, flexible, and scalable code.

-------------------------------------------------------------------------------
1.1 SINGLE RESPONSIBILITY PRINCIPLE (SRP)
-------------------------------------------------------------------------------

DEFINITION:
  "A class should have only one reason to change."
  Each class should focus on doing ONE thing and doing it well.

DETAILED EXPLANATION:
  A class should have a single, well-defined responsibility. If a class has
  multiple responsibilities, changes to one responsibility may affect the others,
  making the code fragile and hard to maintain. SRP promotes high cohesion
  within classes - related functionality grouped together, unrelated functionality
  separated.

EXAMPLE:
  ❌ BAD: A "Customer" class that handles customer data, saves to database,
          sends emails, and generates reports
  
  ✅ GOOD: Separate classes:
          - Customer (data only)
          - CustomerRepository (database operations)
          - EmailService (email notifications)
          - ReportGenerator (report creation)

REAL-WORLD ANALOGY:
  In a restaurant: The chef cooks, the waiter serves, the cashier handles
  payments. Each has ONE clear job. Nobody does everything.

BENEFITS:
  • Easier to understand and maintain
  • Changes are isolated to single classes
  • Better testability (focused unit tests)
  • Improved reusability
  • Reduced coupling between classes

WHEN TO USE:
  • Always! This is a fundamental principle
  • When designing new classes
  • When refactoring "God Objects" (classes doing too much)
  • When you find yourself saying "and" describing class responsibility

COMMON VIOLATIONS:
  • God Objects (classes that do everything)
  • Classes with multiple unrelated methods
  • Mixing business logic with infrastructure concerns (e.g., UI + database)
  • Classes that touch multiple layers of architecture

HOW TO IDENTIFY SRP VIOLATIONS:
  Ask these questions:
  • Can you describe the class responsibility without using "and"?
  • Does the class have more than one reason to change?
  • Are there multiple groups of methods that don't interact?
  • Would changes in one area affect unrelated functionality?

BEST PRACTICES:
  • Keep classes small and focused (< 200 lines is a good guideline)
  • Use descriptive names that reflect single responsibility
  • Separate concerns across layers (presentation, business, data)
  • Follow cohesion - related methods should be together

EXAMPLE FILE: Learning/OOPPrinciples/SingleResponsibilityPrinciple.cs

-------------------------------------------------------------------------------
1.2 OPEN-CLOSED PRINCIPLE (OCP)
-------------------------------------------------------------------------------

DEFINITION:
  "Software entities should be open for extension but closed for modification."
  You should be able to add new functionality without changing existing code.

DETAILED EXPLANATION:
  Use abstractions (interfaces, abstract classes) and polymorphism to allow
  adding new behavior without modifying existing, tested code. This reduces
  the risk of breaking existing functionality when adding new features. The
  idea is to design your code so that when requirements change, you extend
  behavior by adding new code, not by modifying old code.

EXAMPLE:
  ❌ BAD: Modify existing switch/if-else statements every time you add a new type
          
          public double CalculateArea(object shape) {
              if (shape is Circle c) return Math.PI * c.Radius * c.Radius;
              else if (shape is Rectangle r) return r.Width * r.Height;
              // Need to modify this method for every new shape!
          }
  
  ✅ GOOD: Define an interface and add new implementations without touching
           existing code
          
          public interface IShape { double GetArea(); }
          
          public class Circle : IShape {
              public double Radius { get; set; }
              public double GetArea() => Math.PI * Radius * Radius;
          }
          
          public class Rectangle : IShape {
              public double Width { get; set; }
              public double Height { get; set; }
              public double GetArea() => Width * Height;
          }
          
          // Add new shapes without modifying existing code
          public class Triangle : IShape {
              public double Base { get; set; }
              public double Height { get; set; }
              public double GetArea() => 0.5 * Base * Height;
          }

REAL-WORLD ANALOGY:
  Electrical outlets - you can plug in new devices without rewiring your house.
  USB ports - new USB devices work without modifying the port.

BENEFITS:
  • Reduces risk of breaking existing functionality
  • Easier to add new features
  • Better maintainability
  • Follows Don't Repeat Yourself (DRY)
  • Supports plugin architectures

WHEN TO USE:
  • When you anticipate future extensions
  • When building frameworks or libraries
  • Instead of long switch/if-else chains based on types
  • When multiple implementations of same behavior exist

COMMON VIOLATIONS:
  • Switch statements on type codes that keep growing
  • Long if-else chains checking object types (instanceof, is)
  • Modifying existing classes to add new features
  • Hardcoded dependencies that can't be swapped

BEST PRACTICES:
  • Program to interfaces, not implementations
  • Use Strategy pattern for interchangeable algorithms
  • Use Factory pattern for object creation
  • Favor composition over inheritance
  • Keep abstractions stable (interfaces shouldn't change often)

EXAMPLE FILE: Learning/OOPPrinciples/OpenClosedPrinciple.cs

-------------------------------------------------------------------------------
1.3 LISKOV SUBSTITUTION PRINCIPLE (LSP)
-------------------------------------------------------------------------------

DEFINITION:
  "Objects of a superclass should be replaceable with objects of a subclass
   without breaking the application."
  Derived classes must be substitutable for their base classes.

DETAILED EXPLANATION:
  Subclasses should extend, not replace or violate, the behavior of the parent
  class. If code works with a base class, it should work with any derived class
  without modification or unexpected behavior. The derived class should honor
  the contract established by the base class. This is sometimes called "Design
  by Contract" - preconditions cannot be strengthened, postconditions cannot be
  weakened, and invariants must be preserved.

EXAMPLE:
  ❌ BAD: Square inheriting from Rectangle and breaking width/height independence
          
          public class Rectangle {
              public virtual int Width { get; set; }
              public virtual int Height { get; set; }
              public int Area() => Width * Height;
          }
          
          public class Square : Rectangle {
              public override int Width {
                  get => base.Width;
                  set { base.Width = value; base.Height = value; } // Breaks LSP!
              }
              public override int Height {
                  get => base.Height;
                  set { base.Width = value; base.Height = value; } // Breaks LSP!
              }
          }
          
          // This code breaks:
          Rectangle rect = new Square();
          rect.Width = 5;
          rect.Height = 10;
          // Expected: Area = 50, Actual: Area = 100 (both became 10!)
  
  ✅ GOOD: Square and Rectangle both implement IShape independently
          
          public interface IShape {
              double GetArea();
          }
          
          public class Rectangle : IShape {
              public double Width { get; set; }
              public double Height { get; set; }
              public double GetArea() => Width * Height;
          }
          
          public class Square : IShape {
              public double Side { get; set; }
              public double GetArea() => Side * Side;
          }

REAL-WORLD ANALOGY:
  If you have a "Bird" that flies, a "Penguin" (which can't fly) violates LSP
  when inheriting from Bird. All birds should fulfill the contract of what a
  bird does in your system.

BENEFITS:
  • Predictable behavior across inheritance hierarchies
  • Safe polymorphism (you can trust derived types)
  • Reliable code reuse
  • Reduced need for type checking (is, as, instanceof)

WHEN TO USE:
  • Designing inheritance hierarchies
  • Creating base classes and interfaces
  • Ensuring polymorphic code correctness
  • When you want to guarantee substitutability

COMMON VIOLATIONS:
  • Throwing exceptions not thrown by base class
  • Strengthening preconditions (requiring more than base class)
  • Weakening postconditions (guaranteeing less than base class)
  • Changing expected behavior (e.g., readonly property becomes writable)
  • Returning different types than base class declares

HOW TO IDENTIFY LSP VIOLATIONS:
  • Do you need type checks (is/as) after using base class reference?
  • Does derived class throw exceptions base class doesn't?
  • Are there empty/no-op implementations just to satisfy interface?
  • Does derived class change expected behavior in surprising ways?
  • Would a client using base class be surprised by derived class behavior?

BEST PRACTICES:
  • Follow "Design by Contract" principles
  • Ensure derived classes can do everything base class can
  • Don't remove or disable functionality in derived classes
  • Consider composition over inheritance if behavior differs significantly
  • Use interfaces for "can-do" relationships vs inheritance for "is-a"
  • Write tests that work with base class and run them with derived classes

EXAMPLE FILE: Learning/OOPPrinciples/LiskovSubstitutionPrinciple.cs

-------------------------------------------------------------------------------
1.4 INTERFACE SEGREGATION PRINCIPLE (ISP)
-------------------------------------------------------------------------------

DEFINITION:
  "No client should be forced to depend on methods it does not use."
  Create small, focused interfaces rather than large, general-purpose ones.

DETAILED EXPLANATION:
  Large interfaces force implementing classes to provide implementations for
  methods they don't need, creating unnecessary coupling and making code harder
  to maintain. Break down "fat" interfaces into smaller, more specific ones.
  Clients should only know about the methods that are of interest to them.
  This is closely related to SRP but applied to interfaces.

EXAMPLE:
  ❌ BAD: Fat interface forcing all implementations to provide all methods
          
          public interface IWorker {
              void Work();
              void Eat();
              void Sleep();
              void GetPaid();
              void AttendMeeting();
          }
          
          public class Robot : IWorker {
              public void Work() { /* OK */ }
              public void Eat() { throw new NotImplementedException(); } // Forced!
              public void Sleep() { throw new NotImplementedException(); } // Forced!
              public void GetPaid() { throw new NotImplementedException(); } // Forced!
              public void AttendMeeting() { /* Maybe OK? */ }
          }
  
  ✅ GOOD: Separate, focused interfaces
          
          public interface IWorkable {
              void Work();
          }
          
          public interface IFeedable {
              void Eat();
          }
          
          public interface IRestable {
              void Sleep();
          }
          
          public interface IPayable {
              void GetPaid();
          }
          
          public class Robot : IWorkable {
              public void Work() { /* Only implement what robots need */ }
          }
          
          public class Human : IWorkable, IFeedable, IRestable, IPayable {
              public void Work() { }
              public void Eat() { }
              public void Sleep() { }
              public void GetPaid() { }
          }

REAL-WORLD ANALOGY:
  TV remote - you don't need all buttons; you use the ones relevant to you.
  Multi-function printer - you might only need printer functionality, not
  scanner or fax. Better to have separate interfaces.

BENEFITS:
  • Increased flexibility (implement only what you need)
  • Reduced coupling (fewer dependencies)
  • Better organization (clear, focused interfaces)
  • Easier to understand and implement
  • Prevents "fat" interfaces that are hard to maintain

WHEN TO USE:
  • Designing public APIs
  • When different clients need different subsets of functionality
  • When interface has many methods (more than 5-7 is usually a smell)
  • When you see empty implementations or NotImplementedException

COMMON VIOLATIONS:
  • God interfaces (interfaces with many unrelated methods)
  • Empty implementations (throwing NotImplementedException)
  • Implementing interfaces just to satisfy framework requirements
  • Forcing all implementations to provide every method
  • "Kitchen sink" interfaces that try to do everything

HOW TO IDENTIFY ISP VIOLATIONS:
  • Do implementations throw NotImplementedException?
  • Are there many empty method bodies?
  • Does the interface serve multiple distinct purposes?
  • Can you describe the interface without using "and"?
  • Do different clients only use subsets of the interface?

BEST PRACTICES:
  • Keep interfaces small and focused (role interfaces)
  • One interface per client need
  • Use interface composition (class implements multiple small interfaces)
  • Prefer many specific interfaces over one general interface
  • Follow Single Responsibility Principle for interfaces too
  • Name interfaces after their role (ISaveable, ISearchable)

EXAMPLE FILE: Learning/OOPPrinciples/InterfaceSegregationPrinciple.cs

-------------------------------------------------------------------------------
1.5 DEPENDENCY INVERSION PRINCIPLE (DIP)
-------------------------------------------------------------------------------

DEFINITION:
  "High-level modules should not depend on low-level modules. Both should depend
   on abstractions. Abstractions should not depend on details. Details should
   depend on abstractions."

DETAILED EXPLANATION:
  Depend on interfaces or abstract classes, not concrete implementations. This
  inverts the traditional dependency flow where high-level code (business logic)
  depends on low-level code (infrastructure, databases). Now both depend on
  abstractions (interfaces), allowing implementations to be swapped easily. This
  is the foundation for Dependency Injection and Inversion of Control (IoC).

EXAMPLE:
  ❌ BAD: High-level module depends directly on low-level implementation
          
          public class OrderService { // High-level
              private SqlDatabase _db = new SqlDatabase(); // Direct dependency!
              
              public void SaveOrder(Order order) {
                  _db.Save(order); // Tightly coupled to SqlDatabase
              }
          }
  
  ✅ GOOD: Both depend on abstraction (interface)
          
          public interface IDatabase { // Abstraction
              void Save(object entity);
          }
          
          public class OrderService { // High-level
              private readonly IDatabase _database;
              
              // Dependency injected via constructor
              public OrderService(IDatabase database) {
                  _database = database;
              }
              
              public void SaveOrder(Order order) {
                  _database.Save(order); // Depends on abstraction
              }
          }
          
          public class SqlDatabase : IDatabase { // Low-level
              public void Save(object entity) { /* SQL implementation */ }
          }
          
          public class MongoDatabase : IDatabase { // Low-level
              public void Save(object entity) { /* MongoDB implementation */ }
          }
          
          // Usage:
          IDatabase db = new SqlDatabase();
          var service = new OrderService(db); // Can easily swap implementations

REAL-WORLD ANALOGY:
  Wall electrical outlets (abstraction) - you don't care about the power plant
  (implementation). Any compliant device works with any outlet.
  USB standard - devices work with any USB port regardless of manufacturer.

BENEFITS:
  • Loose coupling between modules
  • Easy to test (mock dependencies)
  • Flexible - swap implementations easily
  • Better maintainability
  • Supports plugin architectures
  • Enables unit testing in isolation

WHEN TO USE:
  • Always! This is a fundamental principle
  • When you need to swap implementations (different databases, services)
  • When unit testing (need to mock dependencies)
  • When building layered architectures
  • When multiple implementations of same behavior exist

COMMON VIOLATIONS:
  • Using 'new' keyword to create dependencies inside classes
  • Direct references to concrete classes instead of interfaces
  • Hardcoded file paths, connection strings, configurations
  • Static method calls to concrete implementations
  • Service Locator pattern (considered an anti-pattern by many)

HOW TO ACHIEVE DIP:
  • Dependency Injection:
    - Constructor Injection (preferred - explicit, testable)
    - Property/Setter Injection (optional dependencies)
    - Method Injection (behavior-specific dependencies)
  • IoC (Inversion of Control) containers (.NET's built-in DI)
  • Factory patterns (create abstractions)

BEST PRACTICES:
  • Inject dependencies via constructor (preferred for required dependencies)
  • Program to interfaces, not implementations
  • Use DI containers (ASP.NET Core built-in DI, Autofac, etc.)
  • Keep abstractions stable - implementations can change freely
  • Follow Hollywood Principle: "Don't call us, we'll call you"
  • Avoid Service Locator pattern (hidden dependencies)
  • Use interface-based programming

MODERN .NET IMPLEMENTATION:
  // Program.cs in ASP.NET Core
  var builder = WebApplication.CreateBuilder(args);
  
  // Register dependencies
  builder.Services.AddScoped<IDatabase, SqlDatabase>();
  builder.Services.AddScoped<OrderService>();
  
  var app = builder.Build();
  // Dependencies are automatically injected

EXAMPLE FILE: Learning/OOPPrinciples/DependencyInversionPrinciple.cs

===============================================================================
PART 2: CORE DEVELOPMENT PRINCIPLES
===============================================================================

These principles complement SOLID and guide everyday coding decisions.

-------------------------------------------------------------------------------
2.1 KISS (KEEP IT SIMPLE, STUPID)
-------------------------------------------------------------------------------

DEFINITION:
  "Simplicity should be a key goal; avoid unnecessary complexity."
  Choose the simplest solution that works.

DETAILED EXPLANATION:
  Complex code is harder to understand, maintain, test, and debug. Simple code
  is more maintainable and less bug-prone. Favor readability over cleverness.
  The goal is not to show off your coding skills, but to solve problems in the
  most straightforward way possible. Code is read far more often than it's
  written, so optimize for readability.

EXAMPLES:
  ❌ BAD: Complex one-liner with nested ternaries
          var result = x > 0 ? (y > 0 ? (x > y ? "A" : "B") : "C") : "D";
  
  ✅ GOOD: Clear if-else with descriptive variables
          var result = "";
          if (x > 0) {
              if (y > 0) {
                  result = x > y ? "A" : "B";
              } else {
                  result = "C";
              }
          } else {
              result = "D";
          }
  
  ❌ BAD: Over-engineered solution


❌ BAD: Over-engineered solution with abstrac factory, strategy pattern,
          and dependency injection for a simple calculator
  
  ✅ GOOD: Straightforward switch statement or simple if-else for 4 operations

GUIDELINES:
  • Favor readability over cleverness
  • Use clear, descriptive naming
  • Break complex logic into smaller, well-named methods
  • Avoid premature optimization
  • Write code for humans first, machines second
  • If you need comments to explain what code does, simplify the code
  • One level of abstraction per method

BENEFITS:
  • Easier to understand and maintain
  • Fewer bugs (complexity breeds bugs)
  • Easier to test
  • Faster onboarding for new developers
  • Reduced cognitive load

WHEN TO APPLY:
  • Always, as a default approach
  • Especially in business logic
  • When choosing between multiple solutions of similar effectiveness
  • During code reviews

EXAMPLE FILE: Learning/OOPPrinciples/KISSDRYYAGNIExamples.cs

-------------------------------------------------------------------------------
2.2 DRY (DON'T REPEAT YOURSELF)
-------------------------------------------------------------------------------

DEFINITION:
  "Every piece of knowledge should have a single, authoritative representation."
  Avoid duplicating logic.

DETAILED EXPLANATION:
  When you need to change something, you should only need to change it in one
  place. Duplication leads to maintenance nightmares - bugs need to be fixed
  in multiple places, changes must be synchronized, and inconsistencies creep
  in. DRY isn't just about code duplication, but about knowledge duplication.
  If the same business rule exists in multiple places, that violates DRY.

EXAMPLES:
  ❌ BAD: Same validation logic in multiple controllers
          
          public class UserController {
              public IActionResult Create(User user) {
                  if (string.IsNullOrEmpty(user.Email) || !user.Email.Contains("@"))
                      return BadRequest("Invalid email");
                  // ... rest of logic
              }
          }
          
          public class RegistrationController {
              public IActionResult Register(User user) {
                  if (string.IsNullOrEmpty(user.Email) || !user.Email.Contains("@"))
                      return BadRequest("Invalid email");
                  // ... rest of logic
              }
          }
  
  ✅ GOOD: Centralized validator class
          
          public class EmailValidator {
              public static bool IsValid(string email) {
                  return !string.IsNullOrEmpty(email) && email.Contains("@");
              }
          }
          
          // Use in both controllers
          if (!EmailValidator.IsValid(user.Email))
              return BadRequest("Invalid email");

GUIDELINES:
  • Extract common code into methods or classes
  • Use inheritance or composition appropriately
  • Create reusable utility functions
  • Avoid copy-paste programming
  • Use constants for magic numbers and strings
  • Single source of truth for business rules

BENEFITS:
  • Single source of truth
  • Easier maintenance (change once, fixed everywhere)
  • Reduces bugs (no inconsistencies)
  • Better consistency across codebase
  • Easier refactoring

WHEN TO APPLY:
  • When you copy-paste code
  • When you find yourself making the same change in multiple places
  • When business rules exist in multiple locations
  • During refactoring sessions

BALANCE:
  Don't take DRY to extremes. Sometimes a little duplication is better than
  wrong abstraction. Follow the "Rule of Three" - don't abstract until you
  have three instances of duplication.

EXAMPLE FILE: Learning/OOPPrinciples/KISSDRYYAGNIExamples.cs

-------------------------------------------------------------------------------
2.3 YAGNI (YOU AREN'T GONNA NEED IT)
-------------------------------------------------------------------------------

DEFINITION:
  "Don't implement something until it's actually needed."
  Don't add functionality speculatively.

DETAILED EXPLANATION:
  Adding features "just in case" adds complexity and maintenance burden for
  features that may never be used. It's a form of premature optimization or
  over-engineering. Build what's needed now; refactor when requirements
  actually change. Requirements often change anyway, so code you write for
  future needs often ends up being wrong.

EXAMPLES:
  ❌ BAD: Adding caching, logging, retry logic, circuit breaker, and analytics
          to a simple calculator that just needs to add numbers
  
  ✅ GOOD: Just implement the calculator. Add other features when they're
           actually needed and justified.
  
  ❌ BAD: Creating 10 overloads of a method "in case we need them"
  
  ✅ GOOD: Create the overloads as they're needed

TIME SAVINGS:
  • Stop spending time developing functions you may never use
  • Avoid maintaining code that serves no purpose
  • Faster initial development

CODE QUALITY:
  • Clearer code, free of unused assumptions
  • Less complexity to understand
  • Easier to modify (less code to change)

GUIDELINES:
  • Build what's needed now, not what might be needed later
  • Refactor when requirements actually change
  • Avoid speculative generality
  • Focus on current, validated use cases
  • Let requirements drive features, not imagination

BENEFITS:
  • Reduces complexity
  • Faster development
  • Less code to maintain
  • Focus on actual requirements
  • Avoids wrong abstractions

WHEN TO APPLY:
  • During feature planning
  • When tempted to add "just in case" code
  • During code reviews
  • When estimating work

BALANCE:
  YAGNI doesn't mean zero planning or ignoring extensibility. It means don't
  implement features before they're needed. You can still design for
  extensibility without implementing unused features.

EXAMPLE FILE: Learning/OOPPrinciples/KISSDRYYAGNIExamples.cs

-------------------------------------------------------------------------------
2.4 TDA (TELL, DON'T ASK)
-------------------------------------------------------------------------------

DEFINITION:
  "Tell objects what to do, don't ask for their state and make decisions for
   them."
  Objects should encapsulate behavior and data together.

DETAILED EXPLANATION:
  Instead of getting data from an object and operating on it externally, tell
  the object to perform the operation. This promotes better encapsulation and
  reduces coupling. The object knows how to handle its own data and maintain
  its own invariants. This principle helps avoid "Feature Envy" code smell
  where a method uses more data from another class than its own.

EXAMPLES:
  ❌ BAD (Ask): Getting state and making decisions externally
          
          public class BankAccount {
              public decimal Balance { get; set; }
              public bool IsActive { get; set; }
          }
          
          // Client code asks about state and makes decisions
          if (account.Balance >= amount && account.IsActive) {
              account.Balance -= amount;  // Manipulating state directly
          }
  
  ✅ GOOD (Tell): Tell the object what you want
          
          public class BankAccount {
              private decimal _balance;
              private bool _isActive;
              
              // Object encapsulates the logic
              public bool Withdraw(decimal amount) {
                  if (!_isActive) return false;
                  if (_balance < amount) return false;
                  
                  _balance -= amount;
                  return true;
              }
          }
          
          // Client code just tells what to do
          bool success = account.Withdraw(amount);

REAL-WORLD ANALOGY:
  You tell a waiter "Bring me coffee" - you don't ask "Do you have coffee?",
  "Is the machine working?", "Can you make it?", then tell them step by step
  how to do it. You just tell them what you want.

BENEFITS:
  • Better encapsulation (data and behavior together)
  • Simplified client code (less decision-making logic)
  • Business logic stays with the data
  • Easier to maintain (logic in one place)
  • Reduced coupling (clients don't know internal state)
  • Objects can maintain their invariants

WHEN TO USE:
  • When an object has the data and should have the behavior
  • When you find yourself querying multiple properties
  • When business logic is scattered across clients
  • When designing object-oriented domain models

COMMON VIOLATIONS:
  • Exposing getters and making decisions externally
  • Anemic domain models (data classes without behavior)
  • Client code doing work the object should do
  • Feature envy (method using more data from another class)

HOW TO IDENTIFY TDA VIOLATIONS:
  • Do you call multiple getters in a row?
  • Do you make decisions based on object state externally?
  • Is business logic in service/controller instead of domain model?
  • Are objects just data containers (DTOs everywhere)?

BEST PRACTICES:
  • Put behavior where the data is
  • Rich domain models (behavior + data)
  • Minimize public getters/setters
  • Command methods over query + update patterns
  • Let objects manage their own invariants
  • Encapsulate business rules in the domain objects

BALANCE:
  Still need getters for DTOs, view models, and when genuinely querying state
  for display purposes. The principle is about behavior, not absolute hiding
  of all data. Query methods (getters) are fine; it's the combination of
  query + external decision-making that violates TDA.

EXAMPLE FILE: Learning/OOPPrinciples/TellDontAskPrinciple.cs

===============================================================================
PART 3: DESIGN PATTERNS - CREATIONAL
===============================================================================

Creational patterns deal with object creation mechanisms, creating objects in
a manner suitable to the situation.

-------------------------------------------------------------------------------
3.1 SINGLETON PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Ensure a class has only one instance and provide a global point of access to it.

PURPOSE:
  Restricts instantiation of a class to a single instance. Commonly used for
  logging, configuration managers, connection pools, and caching.

MODERN .NET NOTE:
  "Singleton - replaced by DI lifetimes (AddSingleton)" in modern .NET.
  Use dependency injection with singleton lifetime instead of traditional
  singleton pattern.

TRADITIONAL IMPLEMENTATION:
  // Thread-safe singleton using Lazy<T>
  public sealed class Logger {
      private static readonly Lazy<Logger> _instance =
          new Lazy<Logger>(() => new Logger());
      
      public static Logger Instance => _instance.Value;
      
      private Logger() { }  // Private constructor
      
      public void Log(string message) {
          Console.WriteLine($"[{DateTime.Now}] {message}");
      }
  }
  
  // Usage
  Logger.Instance.Log("Application started");

MODERN .NET IMPLEMENTATION (PREFERRED):
  // Startup.cs or Program.cs
  builder.Services.AddSingleton<ILogger, Logger>();
  
  // Usage (injected via constructor)
  public class MyService {
      private readonly ILogger _logger;
      
      public MyService(ILogger logger) {
          _logger = logger;
      }
      
      public void DoWork() {
          _logger.Log("Doing work");
      }
  }

WHEN TO USE:
  • Configuration managers
  • Thread pools
  • Cache managers
  • Logging services
  • Database connection pools

BENEFITS:
  • Controlled access to sole instance
  • Reduced global namespace pollution
  • Permits refinement of operations  • Variable number of instances (can expand to pool)

CAUTIONS:
  • Can make testing difficult (global state)
  • Can hide dependencies (not visible in constructor)
  • Can create tight coupling
  • Prefer DI with singleton lifetime in modern .NET applications

BEST PRACTICES:
  • Use DI with AddSingleton() in .NET Core/5+
  • If using traditional singleton, make it thread-safe (Lazy<T>)
  • Consider using a factory or builder if construction is complex
  • Make class sealed to prevent inheritance

EXAMPLE FILE: Learning/DesignPatterns/Creational/SingletonPattern.cs

-------------------------------------------------------------------------------
3.2 FACTORY METHOD PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Define an interface for creating an object, but let subclasses decide which
  class to instantiate.

PURPOSE:
  Delegates the instantiation logic to child classes. Useful when a class can't
  anticipate the type of objects it needs to create.

EXAMPLE:
  // Abstract creator
  public abstract class VehicleFactory {
      public abstract IVehicle CreateVehicle();
      
      public void DeliverVehicle() {
          var vehicle = CreateVehicle();
          vehicle.Start();
          vehicle.Drive();
      }
  }
  
  // Concrete creators
  public class CarFactory : VehicleFactory {
      public override IVehicle CreateVehicle() => new Car();
  }
  
  public class BikeFactory : VehicleFactory {
      public override IVehicle CreateVehicle() => new Bike();
  }
  
  // Product interface
  public interface IVehicle {
      void Start();
      void Drive();
  }
  
  // Concrete products
  public class Car : IVehicle {
      public void Start() => Console.WriteLine("Car started");
      public void Drive() => Console.WriteLine("Driving car");
  }

WHEN TO USE:
  • When you don't know the exact types beforehand
  • When creation logic is complex
  • When you want to delegate instantiation to subclasses
  • Payment processors, notification senders, file parsers

BENEFITS:
  • Loose coupling (code doesn't depend on concrete classes)
  • Open-Closed Principle compliance
  • Single Responsibility for creation logic
  • Easy to add new product types

REAL-WORLD EXAMPLES:
  • Document editors (Word, PDF, HTML documents)
  • Payment gateways (PayPal, Stripe, Square)
  • Notification services (Email, SMS, Push)

EXAMPLE FILE: Learning/DesignPatterns/Creational/FactoryMethodPattern.cs

-------------------------------------------------------------------------------
3.3 ABSTRACT FACTORY PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Provide an interface for creating families of related or dependent objects
  without specifying their concrete classes.

PURPOSE:
  Creates groups of related objects. For example, a UI factory might create
  buttons, text fields, and checkboxes that all match a specific theme.

MODERN .NET NOTE:
  "Abstract Factory - DI + generics already cover it" - often unnecessary
  in modern .NET with dependency injection.

EXAMPLE:
  // Abstract factory
  public interface IUIFactory {
      IButton CreateButton();
      ITextBox CreateTextBox();
  }
  
  //Concrete factories
  public class WindowsUIFactory : IUIFactory {
      public IButton CreateButton() => new WindowsButton();
      public ITextBox CreateTextBox() => new WindowsTextBox();
  }
  
  public class MacUIFactory : IUIFactory {
      public IButton CreateButton() => new MacButton();
      public ITextBox CreateTextBox() => new MacTextBox();
  }
  
  // Product interfaces
  public interface IButton { void Render(); }
  public interface ITextBox { void Render(); }

WHEN TO USE:
  • Cross-platform UI components
  • Database providers (SQL Server, PostgreSQL, MySQL)
  • Multiple product families that must work together
  • When you need to enforce consistency among related objects

BENEFITS:
  • Ensures compatibility between products
  • Isolates concrete classes
  • Easy to swap entire product families
  • Promotes consistency

CAUTIONS:
  • Can result in lot of classes
  • Overkill for simple scenarios
  • Modern DI + configuration often simpler

EXAMPLE FILE: Learning/DesignPatterns/Creational/AbstractFactoryPattern.cs

-------------------------------------------------------------------------------
3.4 BUILDER PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Separate the construction of a complex object from its representation.

PURPOSE:
  Allows you to construct complex objects step by step. Produces different
  types and representations using the same construction code.

EXAMPLE:
  public class HttpRequestBuilder {
      private string _url = "";
      private string _method = "GET";
      private Dictionary<string, string> _headers = new();
      private string _body = "";
      
      public HttpRequestBuilder SetUrl(string url) {
          _url = url;
          return this;
      }
      
      public HttpRequestBuilder SetMethod(string method) {
          _method = method;
          return this;
      }
      
      public HttpRequestBuilder AddHeader(string key, string value) {
          _headers[key] = value;
          return this;
      }
      
      public HttpRequestBuilder SetBody(string body) {
          _body = body;
          return this;
      }
      
      public HttpRequest Build() {
          return new HttpRequest(_url, _method, _headers, _body);
      }
  }
  
  // Usage (Fluent Interface)
  var request = new HttpRequestBuilder()
      .SetUrl("https://api.example.com/users")
      .SetMethod("POST")
      .AddHeader("Authorization", "Bearer token")
      .AddHeader("Content-Type", "application/json")
      .SetBody("{\"name\":\"John\"}")
      .Build();

WHEN TO USE:
  • Creating objects with many optional parameters
  • Avoiding "telescoping constructors"
  • Building immutable objects
  • Complex configuration objects

BENEFITS:
  • Clearer than constructors with many parameters
  • Builds objects step-by-step
  • Can reuse same construction code for different representations
  • Supports fluent interfaces (method chaining)

REAL-WORLD EXAMPLES:
  • StringBuilder (built-in .NET example)
  • HttpClient configuration
  • Entity Framework query building
  • Test data builders

EXAMPLE FILE: Learning/DesignPatterns/Creational/BuilderPattern.cs

-------------------------------------------------------------------------------
3.5 PROTOTYPE PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Create new objects by cloning existing ones.

PURPOSE:
  Instead of creating objects from scratch, you clone a prototypical instance.
  Useful when creation is expensive and the object has many similar configurations.

EXAMPLE:
  public class DocumentTemplate : ICloneable {
      public string Header { get; set; }
      public List<string> Content { get; set; } = new();
      public Dictionary<string, string> Metadata { get; set; } = new();
      
      // Deep copy implementation
      public object Clone() {
          return new DocumentTemplate {
              Header = this.Header,
              Content = new List<string>(this.Content),
              Metadata = new Dictionary<string, string>(this.Metadata)
          };
      }
  }
  
  // Usage
  var template = new DocumentTemplate {
      Header = "Company Letter",
      Metadata = { ["Company"] = "Acme Corp" }
  };
  
  var letter1 = (DocumentTemplate)template.Clone();
  letter1.Content.Add("Dear Customer 1");
  
  var letter2 = (DocumentTemplate)template.Clone();
  letter2.Content.Add("Dear Customer 2");

WHEN TO USE:
  • Object creation is expensive (database queries, complex calculations)
  • You need many similar objects with slight variations
  • Objects have many configuration options
  • Avoiding subclasses for each configuration

BENEFITS:
  • Reduces creation costs
  • Simplifies object creation
  • Dynamic configuration at runtime
  • Can add/remove objects at runtime

CAUTIONS:
  • Deep vs shallow copy complexity
  • Cloning objects with circular references can be tricky
  • ICloneable interface doesn't specify deep vs shallow copy

BEST PRACTICES:
  • Implement deep copy when needed (clone nested objects too)
  • Consider using copy constructors or factory methods
  • Document whether your clone is deep or shallow
  • Use record types in C# 9+ for built-in cloning support

EXAMPLE FILE: Learning/DesignPatterns/Creational/PrototypePattern.cs

===============================================================================
PART 4: DESIGN PATTERNS - STRUCTURAL
===============================================================================

Structural patterns deal with object composition, creating relationships
between entities.

-------------------------------------------------------------------------------
4.1 ADAPTER PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Converts the interface of a class into another interface that clients expect.
  Allows incompatible interfaces to work together.

PURPOSE:
  Acts as a translator between two incompatible interfaces. Common when
  integrating legacy systems or third-party libraries.

EXAMPLE:
  // Third-party library with incompatible interface
  public class LegacyPaymentSystem {
      public void ProcessTransaction(string accountNumber, decimal total) {
          Console.WriteLine($"Processing ${total} from account {accountNumber}");
      }
  }
  
  // Our expected interface
  public interface IPaymentProcessor {
      void ProcessPayment(PaymentRequest request);
  }
  
  // Adapter to bridge the gap
  public class LegacyPaymentAdapter : IPaymentProcessor {
      private readonly LegacyPaymentSystem _legacy = new();
      
      public void ProcessPayment(PaymentRequest request) {
          // Translate new interface to old interface
          _legacy.ProcessTransaction(request.AccountNumber, request.Amount);
      }
  }
  
  // Usage
  IPaymentProcessor processor = new LegacyPaymentAdapter();
  processor.ProcessPayment(new PaymentRequest {
      AccountNumber = "123456",
      Amount = 99.99m
  });

WHEN TO USE:
  • Integrating third-party libraries
  • Working with legacy code
  • Making incompatible interfaces compatible
  • Migrating from old to new systems

BENEFITS:
  • Single Responsibility (separation of interfaces)
  • Open/Closed Principle (add adapters without changing existing code)
  • Reuses existing functionality without modification

REAL-WORLD EXAMPLES:
  • Database drivers adapting to common interfaces (ADO.NET)
  • Payment gateway adapters
  • Cloud storage adapters (AWS S3, Azure Blob, Google Cloud)

EXAMPLE FILE: Learning/DesignPatterns/Structural/AdapterPattern.cs

-------------------------------------------------------------------------------
4.2 DECORATOR PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Attaches additional responsibilities to an object dynamically without
  altering its structure.

PURPOSE:
  Alternative to subclassing for extending functionality. Allows adding
  behaviors at runtime by wrapping objects.

EXAMPLE:
  // Base component
  public interface INotifier {
      void Send(string message);
  }
  
  public class EmailNotifier : INotifier {
      public void Send(string message) {
          Console.WriteLine($"Email: {message}");
      }
  }
  
  // Base decorator
  public abstract class NotifierDecorator : INotifier {
      protected INotifier _wrappee;
      
      public NotifierDecorator(INotifier notifier) {
          _wrappee = notifier;
      }
      
      public virtual void Send(string message) {
          _wrappee.Send(message);
      }
  }
  
  // Concrete decorators
  public class SMSDecorator : NotifierDecorator {
      public SMSDecorator(INotifier notifier) : base(notifier) { }
      
      public override void Send(string message) {
          base.Send(message);
          Console.WriteLine($"SMS: {message}");
      }
  }
  
  public class SlackDecorator : NotifierDecorator {
      public SlackDecorator(INotifier notifier) : base(notifier) { }
      
      public override void Send(string message) {
          base.Send(message);
          Console.WriteLine($"Slack: {message}");
      }
  }
  
  // Usage - wrap multiple times
  INotifier notifier = new EmailNotifier();
  notifier = new SMSDecorator(notifier);
  notifier = new SlackDecorator(notifier);
  notifier.Send("Server is down!");
  // Sends via Email, SMS, and Slack

WHEN TO USE:
  • Adding responsibilities dynamically
  • Avoiding subclass explosion
  • Following Open/Closed Principle
  • Stream processing (compression, encryption)

BENEFITS:
  • More flexible than static inheritance
  • Single Responsibility (each decorator has one job)
  • Can combine decorators in various ways
  • Runtime configuration

REAL-WORLD EXAMPLES:
  • Stream decorators (BufferedStream, GZipStream, CryptoStream)
  • Logging decorators
  • Caching decorators
  • Authorization decorators

EXAMPLE FILE: Learning/DesignPatterns/Structural/DecoratorPattern.cs

-------------------------------------------------------------------------------
4.3 FACADE PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Provides a simplified interface to a complex subsystem.

PURPOSE:
  Hides complexity by providing a simple interface to complex systems. Makes
  libraries easier to use and understand.

EXAMPLE:
  // Complex subsystem
  public class VideoFile { /* ... */ }
  public class AudioMixer { /* ... */ }
  public class BitrateReader {
      public string Read(VideoFile file) => "...";
      public string Convert(VideoFile file, string codec) => "...";
  }
  
  public class MPEG4CompressionCodec { /* ... */ }
  public class OggCompressionCodec { /* ... */ }
  
  // Facade simplifies the complex subsystem
  public class VideoConverter {
      public void Convert(string filename, string format) {
          var file = new VideoFile(filename);
          var sourceCodec = new BitrateReader().Read(file);
          
          var destinationCodec = format == "mp4"
              ? new MPEG4CompressionCodec()
              : new OggCompressionCodec();
          
          var buffer = new BitrateReader().Convert(file, sourceCodec);
          var result = destinationCodec.Compress(buffer);
          var audio = new AudioMixer().Fix(result);
          
          // Save file...
      }
  }
  
  // Usage is simple
  var converter = new VideoConverter();
  converter.Convert("video.ogg", "mp4");

WHEN TO USE:
  • Complex subsystems with many interconnected classes
  • Layered architecture (facade for each layer)
  • Providing simple interface to third-party libraries
  • Reducing coupling to subsystems

BENEFITS:
  • Isolates clients from subsystem complexity
  • Promotes weak coupling
  • Easier to use and understand
  • Single entry point for subsystem

REAL-WORLD EXAMPLES:
  • API clients for complex REST APIs
  • Database access layers
  • Framework initialization (e.g., ASP.NET Core startup)
  • Home automation systems (single app controls many devices)

EXAMPLE FILE: Learning/DesignPatterns/Structural/FacadePattern.cs

-------------------------------------------------------------------------------
4.4 COMPOSITE PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Composes objects into tree structures to represent part-whole hierarchies.
  Allows clients to treat individual objects and compositions uniformly.

PURPOSE:
  Works with tree structures where you want to treat leaves and branches the
  same way. Common in file systems, UI components, organization charts.

EXAMPLE:
  // Component interface
  public abstract class FileSystemItem {
      protected string _name;
      
      public FileSystemItem(string name) => _name = name;
      
      public abstract void Display(int depth);
      public abstract long GetSize();
  }
  
  // Leaf
  public class File : FileSystemItem {
      private long _size;
      
      public File(string name, long size) : base(name) => _size = size;
      
      public override void Display(int depth) {
          Console.WriteLine(new string('-', depth) + _name + $" ({_size} bytes)");
      }
      
      public override long GetSize() => _size;
  }
  
  // Composite
  public class Directory : FileSystemItem {
      private List<FileSystemItem> _items = new();
      
      public Directory(string name) : base(name) { }
      
      public void Add(FileSystemItem item) => _items.Add(item);
      public void Remove(FileSystemItem item) => _items.Remove(item);
      
      public override void Display(int depth) {
          Console.WriteLine(new string('-', depth) + _name + "/");
          foreach (var item in _items) {
              item.Display(depth + 2);
          }
      }
      
      public override long GetSize() => _items.Sum(i => i.GetSize());
  }
  
  // Usage
  var root = new Directory("Root");
  root.Add(new File("file1.txt", 100));
  
  var docs = new Directory("Documents");
  docs.Add(new File("doc1.docx", 2000));
  docs.Add(new File("doc2.pdf", 1500));
  root.Add(docs);
  
  root.Display(0);
  Console.WriteLine($"Total size: {root.GetSize()} bytes");

WHEN TO USE:
  • Tree structures (files/folders, UI components, org charts)
  • Treating individual objects and groups uniformly
  • Recursive structures
  • Part-whole hierarchies

BENEFITS:
  • Uniform treatment of leaves and composites
  • Easy to add new component types
  • Simplified client code
  • Open/Closed Principle compliance

REAL-WORLD EXAMPLES:
  • File systems
  • UI component hierarchies (WPF, WinForms)
  • Organization charts
  • Menu systems

EXAMPLE FILE: Learning/DesignPatterns/Structural/CompositePattern.cs

-------------------------------------------------------------------------------
4.5 PROXY PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Provides a surrogate or placeholder to control access to another object.

PURPOSE:
  Controls access to the real object. Can be used for lazy initialization,
  access control, logging, caching, or remote object access.

TYPES OF PROXIES:
  • Virtual Proxy: Lazy initialization (creates object only when needed)
  • Protection Proxy: Access control (checks permissions)
  • Remote Proxy: Represents object in different address space
  • Cache Proxy: Caches results of expensive operations

EXAMPLE:
  // Subject interface
  public interface IImage {
      void Display();
  }
  
  // Real subject (expensive to create)
  public class RealImage : IImage {
      private string _filename;
      
      public RealImage(string filename) {
          _filename = filename;
          LoadFromDisk();  // Expensive operation
      }
      
      private void LoadFromDisk() {
          Console.WriteLine($"Loading {_filename} from disk...");
          Thread.Sleep(1000);  // Simulate expensive load
      }
      
      public void Display() {
          Console.WriteLine($"Displaying {_filename}");
      }
  }
  
  // Proxy (controls access to RealImage)
  public class ImageProxy : IImage {
      private RealImage? _realImage;
      private string _filename;
      
      public ImageProxy(string filename) => _filename = filename;
      
      public void Display() {
          // Lazy initialization - only load when actually needed
          if (_realImage == null) {
              _realImage = new RealImage(_filename);
          }
          _realImage.Display();
      }
  }
  
  // Usage
  IImage image = new ImageProxy("large_photo.jpg");
  // Image not yet loaded
  
  image.Display();  // Loading happens here (lazy)
  image.Display();  // Already loaded, reuses existing object

WHEN TO USE:
  • Lazy initialization (expensive objects)
  • Access control (check permissions before access)
  • Logging, auditing, or monitoring
  • Remote method invocation
  • Caching expensive operations

BENEFITS:
  • Controls object access
  • Lazy initialization saves resources
  • Can add extra functionality transparently
  • Open/Closed Principle (add proxies without changing real object)

REAL-WORLD EXAMPLES:
  • ORM lazy loading (Entity Framework navigation properties)
  • Image galleries (load images only when visible)
  • Access control proxies
  • WCF service proxies

EXAMPLE FILE: Learning/DesignPatterns/Structural/ProxyPattern.cs

-------------------------------------------------------------------------------
4.6 CQRS PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Command Query Responsibility Segregation - separates read (query) operations
  from write (command) operations.

PURPOSE:
  Different data models for reading and writing. Queries don't modify state;
  commands modify state but don't return data (except confirmation).

EXPLANATION:
  In traditional CRUD systems, the same model handles both reads and writes.
  CQRS splits this: one model optimized for commands (business logic,
  validation, updates) and another optimized for queries (fast reads, denormalized views).

EXAMPLE:
  // Command side (writes)
  public class CreateOrderCommand {
      public int CustomerId { get; set; }
      public List<OrderItem> Items { get; set; }
  }
  
  public class CreateOrderCommandHandler {
      private readonly OrderDbContext _db;
      
      public CreateOrderCommandHandler(OrderDbContext db) => _db = db;
      
      public async Task<int> Handle(CreateOrderCommand command) {
          var order = new Order {
              CustomerId = command.CustomerId,
              Items = command.Items,
              CreatedAt = DateTime.UtcNow
          };
          
          _db.Orders.Add(order);
          await _db.SaveChangesAsync();
          return order.Id;
      }
  }
  
  // Query side (reads)
  public class GetOrderQuery {
      public int OrderId { get; set; }
  }
  
  public class GetOrderQueryHandler {
      private readonly IOrderReadModel _readModel;
      
      public GetOrderQueryHandler(IOrderReadModel readModel) => _readModel = readModel;
      
      public async Task<OrderDto> Handle(GetOrderQuery query) {
          return await _readModel.GetOrderById(query.OrderId);
      }
  }
  
  // Separate read model (optimized for queries)
  public interface IOrderReadModel {
      Task<OrderDto> GetOrderById(int id);
      Task<List<OrderSummary>> GetOrdersByCustomer(int customerId);
  }

WHEN TO USE:
  • Complex business logic on writes
  • Different read/write performance requirements
  • High-traffic systems (scale reads separately)
  • Event sourcing
  • When read and write models are significantly different

BENEFITS:
  • Independent scaling (scale reads vs writes separately)
  • Optimized models for each operation
  • Simpler query models
  • Improved performance (denormalized read models)
  • Clear separation of concerns

CAUTIONS:
  • Increased complexity
  • Eventually consistent reads (if using separate databases)
  • Synchronization overhead between read and write models
  • Overkill for simple CRUD applications

BEST PRACTICES:
  • Use MediatR or similar library for command/query dispatching
  • Event sourcing can complement CQRS
  • Keep it simple - only use when justified
  • Eventual consistency is okay for many scenarios

EXAMPLE FILE: Learning/DesignPatterns/Structural/CQRSPattern.cs

===============================================================================
PART 5: DESIGN PATTERNS - BEHAVIORAL
===============================================================================

Behavioral patterns are concerned with algorithms and the assignment of
responsibilities between objects.

-------------------------------------------------------------------------------
5.1 OBSERVER PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Defines a one-to-many dependency between objects so that when one object
  changes state, all its dependents are notified automatically.

PURPOSE:
  Implements distributed event handling systems. Also known as the
  publish-subscribe pattern.

MODERN .NET NOTE:
  Built-in via events, IObservable<T>/IObserver<T>, and Reactive Extensions.

EXAMPLE (Traditional):
  // Subject
  public class StockTicker {
      private decimal _price;
      public event EventHandler<decimal>? PriceChanged;
      
      public decimal Price {
          get => _price;
          set {
              if (_price != value) {
                  _price = value;
                  PriceChanged?.Invoke(this, _price);
              }
          }
      }
  }
  
  // Observers
  public class MobileApp {
      public void Subscribe(StockTicker ticker) {
          ticker.PriceChanged += OnPriceChanged;
      }
      
      private void OnPriceChanged(object? sender, decimal newPrice) {
          Console.WriteLine($"Mobile: Stock price changed to ${newPrice}");
      }
  }
  
  public class WebDashboard {
      public void Subscribe(StockTicker ticker) {
          ticker.PriceChanged += (s, price) =>
              Console.WriteLine($"Web: Stock price changed to ${price}");
      }
  }
  
  // Usage
  var ticker = new StockTicker();
  var app = new MobileApp();
  app.Subscribe(ticker);
  new WebDashboard().Subscribe(ticker);
  
  ticker.Price = 150.00m;  // Both observers notified
  ticker.Price = 152.50m;  // Both observers notified

EXAMPLE (IObservable<T>):
  using System.Reactive.Subjects;
  
  var subject = new Subject<decimal>();
  
  subject.Subscribe(price => Console.WriteLine($"Observer 1: ${price}"));
  subject.Subscribe(price => Console.WriteLine($"Observer 2: ${price}"));
  
  subject.OnNext(100.00m);
  subject.OnNext(105.50m);

WHEN TO USE:
  • GUI event handling
  • Model-View patterns
  • Pub/sub messaging
  • Real-time notifications
  • Stock tickers, chat applications

BENEFITS:
  • Loose coupling between subject and observers
  • Dynamic relationships (add/remove observers at runtime)
  • Broadcast communication
  • Open/Closed Principle

CAUTIONS:
  • Memory leaks if observers don't unsubscribe
  • Order of notification is not guaranteed
  • Can lead to update storms
  • Performance overhead with many observers

BEST PRACTICES:
  • Always unsubscribe to prevent memory leaks
  • Use weak event patterns for long-lived subjects
  • Consider Reactive Extensions for complex event streams
  • Document threading behavior

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/ObserverPattern.cs

-------------------------------------------------------------------------------
5.2 STRATEGY PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Defines a family of algorithms, encapsulates each one, and makes them
  interchangeable.

PURPOSE:
  Strategy lets the algorithm vary independently from clients that use it.
  Implements different behaviors using composition instead of inheritance.

EXAMPLE:
  // Strategy interface
  public interface IPaymentStrategy {
      void Pay(decimal amount);
  }
  
  // Concrete strategies
  public class CreditCardStrategy : IPaymentStrategy {
      private string _cardNumber;
      
      public CreditCardStrategy(string cardNumber) => _cardNumber = cardNumber;
      
      public void Pay(decimal amount) {
          Console.WriteLine($"Paid ${amount} using credit card ****{_cardNumber.Substring(12)}");
      }
  }
  
  public class PayPalStrategy : IPaymentStrategy {
      private string _email;
      
      public PayPalStrategy(string email) => _email = email;
      
      public void Pay(decimal amount) {
          Console.WriteLine($"Paid ${amount} using PayPal account {_email}");
      }
  }
  
  public class CryptoStrategy : IPaymentStrategy {
      private string _walletAddress;
      
      public CryptoStrategy(string walletAddress) => _walletAddress = walletAddress;
      
      public void Pay(decimal amount) {
          Console.WriteLine($"Paid ${amount} using crypto wallet {_walletAddress}");
      }
  }
  
  // Context
  public class ShoppingCart {
      private IPaymentStrategy _paymentStrategy;
      
      public void SetPaymentStrategy(IPaymentStrategy strategy) {
          _paymentStrategy = strategy;
      }
      
      public void Checkout(decimal amount) {
          _paymentStrategy.Pay(amount);
      }
  }
  
  // Usage
  var cart = new ShoppingCart();
  
  cart.SetPaymentStrategy(new CreditCardStrategy("1234567812345678"));
  cart.Checkout(100.00m);
  
  cart.SetPaymentStrategy(new PayPalStrategy("user@example.com"));
  cart.Checkout(50.00m);

WHEN TO USE:
  • Multiple algorithms for a specific task
  • Avoiding conditional statements
  • Runtime algorithm selection
  • Payment processing, sorting, validation, compression

BENEFITS:
  • Open/Closed Principle (add strategies without changing context)
  • Single Responsibility (algorithm separated from context)
  • Runtime flexibility
  • Eliminates conditional statements

REAL-WORLD EXAMPLES:
  • Sorting algorithms (QuickSort, MergeSort, BubbleSort)
  • Compression algorithms (ZIP, RAR, 7Z)
  • Payment methods
  • Route calculation (fastest, shortest, scenic)

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/StrategyPattern.cs

-------------------------------------------------------------------------------
5.3 COMMAND PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Encapsulates a request as an object, allowing parameterization and queuing
  of requests.

PURPOSE:
  Turns requests into stand-alone objects containing all request information.
  Enables undo/redo, logging, transactional behavior, and queuing.

EXAMPLE:
  // Command interface
  public interface ICommand {
      void Execute();
      void Undo();
  }
  
  // Receiver
  public class TextEditor {
      public string Text { get; set; } = "";
      
      public void Write(string text) => Text += text;
      public void Delete(int length) => Text = Text.Substring(0, Math.Max(0, Text.Length - length));
  }
  
  // Concrete commands
  public class WriteCommand : ICommand {
      private TextEditor _editor;
      private string _text;
      
      public WriteCommand(TextEditor editor, string text) {
          _editor = editor;
          _text = text;
      }
      
      public void Execute() => _editor.Write(_text);
      public void Undo() => _editor.Delete(_text.Length);
  }
  
  public class DeleteCommand : ICommand {
      private TextEditor _editor;
      private int _length;
      private string _deletedText = "";
      
      public DeleteCommand(TextEditor editor, int length) {
          _editor = editor;
          _length = length;
      }
      
      public void Execute() {
          int start = Math.Max(0, _editor.Text.Length - _length);
          _deletedText = _editor.Text.Substring(start);
          _editor.Delete(_length);
      }
      
      public void Undo() => _editor.Write(_deletedText);
  }
  
  // Invoker
  public class CommandHistory {
      private Stack<ICommand> _history = new();
      
      public void ExecuteCommand(ICommand command) {
          command.Execute();
          _history.Push(command);
      }
      
      public void Undo() {
          if (_history.Count > 0) {
              var command = _history.Pop();
              command.Undo();
          }
      }
  }
  
  // Usage
  var editor = new TextEditor();
  var history = new CommandHistory();
  
  history.ExecuteCommand(new WriteCommand(editor, "Hello "));
  history.ExecuteCommand(new WriteCommand(editor, "World"));
  Console.WriteLine(editor.Text);  // "Hello World"
  
  history.Undo();
  Console.WriteLine(editor.Text);  // "Hello "
  
  history.Undo();
  Console.WriteLine(editor.Text);  // ""

WHEN TO USE:
  • Undo/redo functionality
  • Command queuing
  • Logging operations
  • Transactional behavior
  • GUI buttons/menu items

BENEFITS:
  • Single Responsibility (separates invocation from execution)
  • Open/Closed (add new commands without changing invoker)
  • Undo/redo support
  • Deferred execution
  • Command queuing and logging

REAL-WORLD EXAMPLES:
  • Text editor undo/redo
  • Database transactions
  • UI command buttons
  • Job queues
  • Macro recording

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/CommandPattern.cs

-------------------------------------------------------------------------------
5.4 MEDIATOR PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Defines an object that encapsulates how a set of objects interact, reducing
  coupling between them.

PURPOSE:
  Reduces chaotic dependencies between objects by forcing them to communicate  indirectly through a mediator.

EXAMPLE:
  // Mediator interface
  public interface IChatMediator {
      void SendMessage(string message, User user);
      void RegisterUser(User user);
  }
  
  // Concrete mediator
  public class ChatRoom : IChatMediator {
      private List<User> _users = new();
      
      public void RegisterUser(User user) {
          _users.Add(user);
          user.SetMediator(this);
      }
      
      public void SendMessage(string message, User sender) {
          foreach (var user in _users) {
              // Don't send message back to sender
              if (user != sender) {
                  user.Receive(message, sender);
              }
          }
      }
  }
  
  // Colleague
  public class User {
      private string _name;
      private IChatMediator? _mediator;
      
      public User(string name) => _name = name;
      
      public void SetMediator(IChatMediator mediator) => _mediator = mediator;
      
      public void Send(string message) {
          Console.WriteLine($"{_name} sends: {message}");
          _mediator?.SendMessage(message, this);
      }
      
      public void Receive(string message, User from) {
          Console.WriteLine($"{_name} receives from {from._name}: {message}");
      }
  }
  
  // Usage
  var chatRoom = new ChatRoom();
  
  var alice = new User("Alice");
  var bob = new User("Bob");
  var charlie = new User("Charlie");
  
  chatRoom.RegisterUser(alice);
  chatRoom.RegisterUser(bob);
  chatRoom.RegisterUser(charlie);
  
  alice.Send("Hello everyone!");
  // Bob and Charlie receive the message

WHEN TO USE:
  • Complex communication between many objects
  • Reducing coupling between components
  • Centralizing control logic
  • Chat applications, air traffic control, UI form validation

BENEFITS:
  • Single Responsibility (communication logic in one place)
  • Open/Closed (add new colleagues without changing others)
  • Reduced coupling between components
  • Easier to understand object interactions

CAUTIONS:
  • Mediator can become a "God Object"
  • May be overkill for simple interactions

REAL-WORLD EXAMPLES:
  • Chat rooms
  • Air traffic control
  • UI dialog coordinators
  • MVC controllers (mediating between Model and View)

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/MediatorPattern.cs

-------------------------------------------------------------------------------
5.5 STATE PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Allows an object to alter its behavior when its internal state changes.

PURPOSE:
  Object appears to change its class. Eliminates conditional state logic by
  encapsulating state-specific behavior in separate classes.

EXAMPLE:
  // Context
  public class TrafficLight {
      private ITrafficLightState _state;
      
      public TrafficLight() {
          _state = new RedState();  // Initial state
      }
      
      public void SetState(ITrafficLightState state) => _state = state;
      
      public void Change() => _state.Change(this);
  }
  
  // State interface
  public interface ITrafficLightState {
      void Change(TrafficLight context);
  }
  
  // Concrete states
  public class RedState : ITrafficLightState {
      public void Change(TrafficLight context) {
          Console.WriteLine("Red -> Green");
          context.SetState(new GreenState());
      }
  }
  
  public class GreenState : ITrafficLightState {
      public void Change(TrafficLight context) {
          Console.WriteLine("Green -> Yellow");
          context.SetState(new YellowState());
      }
  }
  
  public class YellowState : ITrafficLightState {
      public void Change(TrafficLight context) {
          Console.WriteLine("Yellow -> Red");
          context.SetState(new RedState());
      }
  }
  
  // Usage
  var light = new TrafficLight();
  light.Change();  // Red -> Green
  light.Change();  // Green -> Yellow
  light.Change();  // Yellow -> Red

WHEN TO USE:
  • Object behavior depends on its state
  • Large conditional statements based on state
  • State transitions are well-defined
  • Workflow engines, game character states, connection states

BENEFITS:
  • Single Responsibility (state-specific code in separate classes)
  • Open/Closed (add new states without changing existing ones)
  • Simplifies context code (eliminates conditionals)
  • Clear state transitions

CAUTIONS:
  • Overkill for simple state machines
  • Increases number of classes

REAL-WORLD EXAMPLES:
  • TCP connection states (Listening, Established, Closed)
  • Order states (Pending, Processing, Shipped, Delivered)
  • Game character states (Idle, Walking, Running, Jumping)
  • Media player states (Playing, Paused, Stopped)

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/StatePattern.cs

-------------------------------------------------------------------------------
5.6 CHAIN OF RESPONSIBILITY PATTERN
-------------------------------------------------------------------------------

DEFINITION:
  Passes a request along a chain of handlers. Each handler decides either to
  process the request or pass it to the next handler.

PURPOSE:
  Decouples sender from receivers. Allows multiple handlers without the sender
  knowing which will ultimately handle the request.

EXAMPLE:
  // Handler interface
  public abstract class LogHandler {
      protected LogHandler? _next;
      protected LogLevel _level;
      
      protected LogHandler(LogLevel level) => _level = level;
      
      public void SetNext(LogHandler handler) => _next = handler;
      
      public void Log(LogLevel level, string message) {
          if (level >= _level) {
              Write(message);
          }
          _next?.Log(level, message);
      }
      
      protected abstract void Write(string message);
  }
  
  public enum LogLevel { Debug = 1, Info = 2, Warning = 3, Error = 4 }
  
  // Concrete handlers
  public class ConsoleLogger : LogHandler {
      public ConsoleLogger(LogLevel level) : base(level) { }
      protected override void Write(string message) {
          Console.WriteLine($"Console: {message}");
      }
  }
  
  public class FileLogger : LogHandler {
      public FileLogger(LogLevel level) : base(level) { }
      protected override void Write(string message) {
          Console.WriteLine($"File: {message}");
      }
  }
  
  public class EmailLogger : LogHandler {
      public EmailLogger(LogLevel level) : base(level) { }
      protected override void Write(string message) {
          Console.WriteLine($"Email: {message}");
      }
  }
  
  // Usage
  var console = new ConsoleLogger(LogLevel.Debug);
  var file = new FileLogger(LogLevel.Info);
  var email = new EmailLogger(LogLevel.Error);
  
  console.SetNext(file);
  file.SetNext(email);
  
  console.Log(LogLevel.Debug, "Debug message");    // Console only
  console.Log(LogLevel.Info, "Info message");      // Console + File
  console.Log(LogLevel.Error, "Error message");    // Console + File + Email

WHEN TO USE:
  • Multiple handlers for a request
  • Handler not known in advance
  • Logging, authentication, validation pipelines
  • Middleware in ASP.NET Core

BENEFITS:
  • Reduced coupling
  • Flexible responsibility assignment
  • Open/Closed (add handlers without changing client)
  • Request can be handled by multiple handlers

CAUTIONS:
  • Request might not be handled (no matching handler)
  • Debugging can be difficult
  • Performance overhead with long chains

REAL-WORLD EXAMPLES:
  • Logging systems
  • Exception handling
  • ASP.NET Core middleware pipeline
  • Event bubbling in GUI frameworks

EXAMPLE FILE: Learning/DesignPatterns/Behavioral/ChainOfResponsibilityPattern.cs

===============================================================================
PART 6: MEMORY MANAGEMENT
===============================================================================

Understanding memory management is critical for writing high-performance,
reliable .NET applications.

-------------------------------------------------------------------------------
6.1 STACK VS HEAP
-------------------------------------------------------------------------------

STACK:
  • Fast, automatic memory allocation
  • Stores value types and method call frames
  • Limited size (typically 1 MB per thread)
  • Memory freed automatically when method returns (LIFO)
  • No garbage collection needed

HEAP:
  • Slower allocation (but optimized by GC)
  • Stores reference types and boxed value types
  • Much larger than stack (limited only by available memory)
  • Managed by Garbage Collector
  • Memory freed when GC determines object is no longer referenced

VALUE TYPES (Stack):
  • Primitive types: int, decimal, bool, char, DateTime, etc.
  • Structs
  • Enums
  • ValueTuple
  
  When assigned or passed, VALUE is copied.

REFERENCE TYPES (Heap):
  • Classes
  • Strings
  • Arrays
  • Delegates
  
  When assigned or passed, REFERENCE is copied (both point to same object).

EXAMPLE:
  // Value types - copied by value
  struct Point {
      public int X;
      public int Y;
  }
  
  Point p1 = new Point { X = 10, Y = 20 };
  Point p2 = p1;  // COPY of value
  p2.X = 99;
  // p1.X is still 10, p2.X is 99
  
  // Reference types - copied by reference
  class Person {
      public string Name { get; set; }
  }
  
  var alice = new Person { Name = "Alice" };
  var bob = alice;  // COPY of reference (same object)
  bob.Name = "Bob";
  // alice.Name is now "Bob" (same object)

BOXING AND UNBOXING:
  Boxing: Converting value type to reference type (allocated on heap)
  Unboxing: Extracting value type from boxed object
  
  int value = 123;
  object boxed = value;  // Boxing: int -> object (heap allocation)
  int unboxed = (int)boxed;  // Unboxing: object -> int
  
  // Performance cost! Avoid boxing in performance-critical code.
  // Use generics to avoid boxing: List<int> instead of ArrayList

WHEN TO USE STRUCT VS CLASS:
  Use struct when:
  • Data is small (< 16 bytes recommended)
  • Immutable
  • Value  semantics desired (copy behavior)
  • Short-lived

  Use class when:
  • Data is large
  • Mutable
  • Reference semantics desired (shared object)
  • Long-lived
  • Inheritance needed

EXAMPLE FILES:
  - Memory/StackVsHeapExample.cs
  - Memory/BoxingUnboxingExample.cs

-------------------------------------------------------------------------------
6.2 GARBAGE COLLECTION
-------------------------------------------------------------------------------

HOW IT WORKS:
  .NET's GC automatically reclaims memory from objects that are no longer
  reachable. Uses generational collection for efficiency.

GENERATIONS:
  Gen 0: Newly allocated objects (frequent collection)
  Gen 1: Survived one collection (medium frequency)
  Gen 2: Long-lived objects (infrequent collection)
  LOH (Large Object Heap): Objects >= 85,000 bytes (special handling)

GC PROCESS:
  1. Mark: Identify live objects starting from roots
  2. Compact: Move live objects together, freeing contiguous memory
  3. Update references: Fix pointers to moved objects

GC TRIGGERS:
  • Gen 0 fills up (most common)
  • Explicit call to GC.Collect() (avoid in production!)
  • Low memory situation
  • Application domain unload

ROOTS (GC starts from these):
  • Static fields
  • Local variables on stack
  • CPU registers
  • GC handles
  • Finalization queue

EXAMPLE:
  // Objects become eligible for GC when no longer reachable
  public class Demo {
      public byte[] BigData = new byte[1000000];
  }
  
  void Method() {
      var demo = new Demo();  // Allocated on heap
      // Use demo...
  }  // demo goes out of scope - eligible for GC
  
  // Large object heap (LOH) - objects >= 85K bytes
  byte[] largeArray = new byte[100_000];  // Goes to LOH
  // LOH is only compacted in specific scenarios

GC MODES:
  • Workstation GC: Optimized for UI responsiveness
  • Server GC: Optimized for throughput (multiple heaps, one per CPU)

CONFIGURATION (project file or runtimeconfig.json):
  <ServerGarbageCollection>true</ServerGarbageCollection>
  <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection>

BEST PRACTICES:
  • Don't call GC.Collect() unless you really know why
  • Minimize allocations in hot paths
  • Use object pools for frequently allocated objects
  • Avoid finalizers (use IDisposable instead)
  • Keep objects short-lived when possible
  • Use struct for small, immutable data
  • Be aware of LOH behavior

EXAMPLE FILE: Memory/GarbageCollectionExample.cs

-------------------------------------------------------------------------------
6.3 MEMORY LEAKS IN .NET
-------------------------------------------------------------------------------

COMMON CAUSES:
  1. Event handlers not unsubscribed
  2. Static references holding objects
  3. Unmanaged resources not disposed
  4. Cache without expiration
  5. Circular references with finalizers

1. EVENT HANDLER LEAK:
  // LEAK: Event handler keeps object alive
  public class Publisher {
      public event EventHandler<string>? OnData;
  }
  
  public class Subscriber {
      public Subscriber(Publisher pub) {
          pub.OnData += HandleData; // Subscription creates reference
      }
      
      void HandleData(object? sender, string data) { /* ... */ }
      // Problem: If Publisher lives longer than Subscriber, Subscriber won't be GC'd
  }
  
  // FIX: Unsubscribe in Dispose
  public class Subscriber : IDisposable {
      private Publisher _pub;
      
      public Subscriber(Publisher pub) {
          _pub = pub;
          _pub.OnData += HandleData;
      }
      
      void HandleData(object? sender, string data) { /* ... */ }
      
      public void Dispose() {
          _pub.OnData -= HandleData;  // Unsubscribe!
      }
  }

2. STATIC REFERENCE LEAK:
  // LEAK: Static list keeps objects alive forever
  public static class Cache {
      private static List<byte[]> _data = new();
      
      public static void Add(byte[] data) {
          _data.Add(data);  // Never removed!
      }
  }
  
  // FIX: Use weak references or expiration
  public static class Cache {
      private static Dictionary<string, (byte[] Data, DateTime Expiry)> _data = new();
      
      public static void Add(string key, byte[] data, TimeSpan ttl) {
          _data[key] = (data, DateTime.UtcNow.Add(ttl));
      }
      
      public static void CleanExpired() {
          var Now = DateTime.UtcNow;
          var expired = _data.Where(kvp => kvp.Value.Expiry < now).Select(kvp => kvp.Key).ToList();
          foreach (var key in expired) _data.Remove(key);
      }
  }

3. UNMANAGED RESOURCE LEAK:
  // LEAK: FileStream not disposed
  void ProcessFile(string path) {
      var stream = new FileStream(path, FileMode.Open);
      // Process...
  }  // Stream not disposed - handle leak
  
  // FIX: Use using statement
  void ProcessFile(string path) {
      using var stream new FileStream(path, FileMode.Open);
      // Process...
  }  // Disposed automatically

DETECTION TOOLS:
  • Visual Studio Diagnostic Tools
  • dotMemory (JetBrains)
  • PerfView (Microsoft)
  • Windows Performance Analyzer
  • ANTS Memory Profiler (Redgate)

BEST PRACTICES:
  • Always implement IDisposable for classes using unmanaged resources
  • Use using statements or async using
  • Unsubscribe from events in Dispose
  • Be cautious with static references
  • Use weak references when appropriate
  • Implement caching with expiration
  • Profile memory regularly

EXAMPLE FILE: Memory/MemoryLeakExamples.cs

-------------------------------------------------------------------------------
6.4 IDisposable PATTERN
-------------------------------------------------------------------------------

PURPOSE:
  Provides deterministic cleanup of unmanaged resources (file handles, database
  connections, network sockets, etc.).

DISPOSE PATTERN (Full Implementation):
  public class ResourceHolder : IDisposable {
      // Unmanaged resource
      private IntPtr _unmanagedResource;
      
      // Managed resource
      private FileStream? _managedResource;
      
      // Track disposal status
      private bool _disposed = false;
      
      public ResourceHolder() {
          _unmanagedResource = /* allocate */;
          _managedResource = new FileStream(/* ... */);
      }
      
      // Public Dispose method
      public void Dispose() {
          Dispose(disposing: true);
          GC.SuppressFinalize(this);  // Don't call finalizer
      }
      
      // Protected Dispose method (for inheritance)
      protected virtual void Dispose(bool disposing) {
          if (_disposed) return;
          
          if (disposing) {
              // Dispose managed resources
              _managedResource?.Dispose();
          }
          
          // Free unmanaged resources (always, even if disposing=false)
          if (_unmanagedResource != IntPtr.Zero) {
              // Free unmanaged resource
              _unmanagedResource = IntPtr.Zero;
          }
          
          _disposed = true;
      }
      
      // Finalizer (only if you have unmanaged resources)
      ~ResourceHolder() {
          Dispose(disposing: false);
      }
      
      // Helper to throw if disposed
      private void ThrowIfDisposed() {
          if (_disposed) throw new ObjectDisposedException(GetType().Name);
      }
      
      public void DoWork() {
          ThrowIfDisposed();
          // Use resources...
      }
  }

USAGE:
  // using statement (C# 8+)
  using var resource = new ResourceHolder();
  resource.DoWork();
  // Dispose called automatically
  
  // using block (traditional)
  using (var resource = new ResourceHolder()) {
      resource.DoWork();
  }  // Dispose called here
  
  // Manual (not recommended)
  var resource = new ResourceHolder();
  try {
      resource.DoWork();
  }
  finally {
      resource.Dispose();
  }

ASYNC DISPOSE (IAsyncDisposable):
  public class AsyncResourceHolder : IAsyncDisposable {
      private DbConnection? _connection;
      
      public async ValueTask DisposeAsync() {
          if (_connection != null) {
              await _connection.CloseAsync();
              _connection.Dispose();
          }
      }
  }
  
  // Usage
  await using var resource = new AsyncResourceHolder();

WHEN TO IMPLEMENT:
  • Your class directly uses unmanaged resources
  • Your class holds fields that implement IDisposable
  • Your class manage resources that should be cleaned up deterministically

WHEN NOT TO IMPLEMENT:
  • Class only contains managed resources that don't implement IDisposable
  • Class is purely computational

BEST PRACTICES:
  • Always use 'using' for IDisposable objects
  • Implement full pattern if you have unmanaged resources
  • Make Dispose idempotent (safe to call multiple times)
  • Don't throw exceptions from Dispose
  • Consider IAsyncDisposable for async cleanup
  • Document disposal requirements

EXAMPLE FILE: Memory/DisposablePatternExample.cs

===============================================================================
PART 7: ASYNC & MULTITHREADING
===============================================================================

Modern applications require asynchronous and concurrent programming for
responsiveness and performance.

-------------------------------------------------------------------------------
7.1 ASYNC/AWAIT
-------------------------------------------------------------------------------

PURPOSE:
  Write asynchronous code that looks synchronous. Improves scalability by
  not blocking threads during I/O operations.

HOW IT WORKS:
  • async marks a method as asynchronous
  • await suspends method execution until the awaited task completes
  • Compiler transforms method into state machine
  • Thread is released during await (not blocked)

EXAMPLE:
  // Synchronous (blocks thread)
  public string DownloadSync(string url) {
      using var client = new HttpClient();
      return client.GetStringAsync(url).Result;  // BLOCKS thread
  }
  
  // Asynchronous (doesn't block)
  public async Task<string> DownloadAsync(string url) {
      using var client = new HttpClient();
      return await client.GetStringAsync(url);  // Awaits without blocking
  }

TASK VS TASK<T>:
  • Task: Asynchronous operation with no return value
  • Task<T>: Asynchronous operation returning value of type T
  
  async Task DoWorkAsync() {  // Returns void (as Task)
      await Task.Delay(100);
  }
  
  async Task<int> GetNumberAsync() {  // Returns int (as Task<int>)
      await Task.Delay(100);
      return 42;
  }

ASYNC VOID (Avoid!):
  // BAD: Can't await, exceptions are hard to handle
  async void HandleClick() {
      await DoWorkAsync();
  }
  
  // GOOD: Return Task
  async Task HandleClickAsync() {
      await DoWorkAsync();
  }
  
  // Exception: Event handlers must be async void
  button.Click += async (s, e) => await HandleClickAsync();

CONFIGUREAWAIT:
  // Library code: Don't capture context
  await DoWorkAsync().ConfigureAwait(false);
  
  // UI code: Capture context (default)
  await DoWorkAsync();  // Resumes on original context (UI thread)

PARALLEL OPERATIONS:
  // Sequential (slow)
  var result1 = await DoWork1Async();
  var result2 = await DoWork2Async();
  
  // Parallel (fast)
  var task1 = DoWork1Async();
  var task2 = DoWork2Async();
  await Task.WhenAll(task1, task2);
  var result1 = task1.Result;
  var result2 = task2.Result;
  
  // Or with results
  var results = await Task.WhenAll(DoWork1Async(), DoWork2Async());

ASYNC BEST PRACTICES:
  • Async all the way (don't mix sync/async)
  • Never use .Result or .Wait() (causes deadlocks)
  • Use Task instead of async void (except event handlers)
  • Use ConfigureAwait(false) in library code
  • Don't async methods that don't await
  • Use CancellationToken for cancellable operations
  • Handle exceptions properly (AggregateException for Task.WhenAll)

CANCELLATION:
  async Task DoWorkAsync(CancellationToken cancellationToken) {
      for (int i = 0; i < 100; i++) {
          cancellationToken.ThrowIfCancellationRequested();
          await Task.Delay(100, cancellationToken);
      }
  }
  
  // Usage
  var cts = new CancellationTokenSource();
  var task = DoWorkAsync(cts.Token);
  
  // Cancel after 2 seconds
  cts.CancelAfter(TimeSpan.FromSeconds(2));
  
  try {
      await task;
  }
  catch (OperationCanceledException) {
      Console.WriteLine("Operation cancelled");
  }

EXAMPLE FILE: Async/AsyncAwaitExamples.cs

-------------------------------------------------------------------------------
7.2 TASK VS THREAD VS VALUETASK
-------------------------------------------------------------------------------

THREAD:
  • OS-level thread
  • Heavy resource usage (1 MB stack per thread)
  • Direct control over thread
  • Use for long-running CPU-bound work
  
  var thread = new Thread(() => {
      // Long-running work
  });
  thread.Start();
  thread.Join();  // Wait for completion

TASK:
  • Abstraction over threads (Task Parallel Library)
  • Uses thread pool (reuses threads)
  • Supports async/await
  • Preferred for most scenarios
  
  var task = Task.Run(() => {
      // Work
  });
  await task;

VALUETASK<T>:
  • Struct (value type)
  • Performance optimization for cases where result is often synchronous
  • Reduces allocations when result is immediately available
  • More complex to use correctly
  
  ValueTask<int> GetValueAsync(bool fast) {
      if (fast) {
          return new ValueTask<int>(42);  // Synchronous, no allocation
      }
      return new ValueTask<int>(GetSlowAsync());  // Wraps Task
  }
  
  async Task<int> GetSlowAsync() {
      await Task.Delay(1000);
      return 42;
  }

WHEN TO USE WHAT:
  • Task: Default choice for async operations
  • ValueTask: High-performance scenarios with often-sync results (caching)
  • Thread: Long-running CPU-bound work, need dedicated thread

THREAD POOL:
  • Manages a pool of worker threads
  • Reuses threads instead of creating new ones
  • Task.Run uses thread pool
  • Don't use for long-running work (starves pool)
  
  // Thread pool
  ThreadPool.QueueUserWorkItem(_ => {
      // Short work
  });
  
  // Or better, use Task
  await Task.Run(() => {
      // Short work
  });

EXAMPLE FILE: Async/TaskVsThreadExample.cs

-------------------------------------------------------------------------------
7.3 DEADLOCKS & PREVENTION
-------------------------------------------------------------------------------

WHAT IS A DEADLOCK?
  Two or more threads waiting indefinitely for each other to release resources.

COMMON CAUSE IN ASYNC CODE:
  // DEADLOCK: Blocking on async code
  public void DeadlockExample() {
      var result = DoWorkAsync().Result;  // BLOCKS waiting for task
      // But task is trying to resume on this thread (captured context)
      // -> Deadlock!
  }
  
  async Task DoWorkAsync() {
      await Task.Delay(100);
      // Tries to resume on original context (blocked above)
  }

PREVENTION:
  1. Don't block on async code (.Result, .Wait())
  2. Use async all the way
  3. Use ConfigureAwait(false) in library code
  4. Use proper lock ordering
  
  // FIX 1: Async all  the way
  public async Task CorrectExample() {
      var result = await DoWorkAsync();  // No blocking
  }
  
  // FIX 2: ConfigureAwait(false)
  async Task DoWorkAsync() {
      await Task.Delay(100).ConfigureAwait(false);  // Don't capture context
  }

LOCK DEADLOCK:
  object lock1 = new();
  object lock2 = new();
  
  // Thread 1
  lock (lock1) {
      Thread.Sleep(100);
      lock (lock2) {  // Waits for lock2
          // Work
      }
  }
  
  // Thread 2
  lock (lock2) {
      Thread.Sleep(100);
      lock (lock1) {  // Waits for lock1 -> Deadlock!
          // Work
      }
  }
  
  // FIX: Always acquire locks in same order
  // Both threads: lock(lock1) then lock(lock2)

SEMAPHORESLIM FOR ASYNC:
  // Don't use lock with async/await
  // Use SemaphoreSlim instead
  
  private readonly SemaphoreSlim _semaphore = new(1, 1);
  
  public async Task DoWorkAsync() {
      await _semaphore.WaitAsync();
      try {
          // Critical section
          await SomeAsyncWork();
      }
      finally {
          _semaphore.Release();
      }
  }

BEST PRACTICES:
  • Never block on async code (.Result, .Wait())
  • Async all the way (no mixing sync/async)
  • Use ConfigureAwait(false) in libraries
  • Consistent lock ordering
  • Use timeout on lock acquisition
  • Consider lock-free data structures
  • Use async-friendly primitives (SemaphoreSlim)

EXAMPLE FILE: Async/DeadlockExamples.cs

-------------------------------------------------------------------------------
7.4 THREAD-SAFE COLLECTIONS
-------------------------------------------------------------------------------

WHY NEEDED:
  Standard collections (List, Dictionary, etc.) are NOT thread-safe for writes.
  Concurrent access can cause corruption or exceptions.

SYSTEM.COLLECTIONS.CONCURRENT:
  • ConcurrentDictionary<TKey, TValue>
  • ConcurrentQueue<T>
  • ConcurrentStack<T>
  • ConcurrentBag<T>
  • BlockingCollection<T>

CONCURRENT DICTIONARY:
  var dict = new ConcurrentDictionary<int, string>();
  
  // Thread-safe operations
  dict.TryAdd(1, "one");
  dict.TryGetValue(1, out var value);
  dict.TryRemove(1, out var removed);
  dict.TryUpdate(1, "ONE", "one");  // Update if current value matches
  
  // AddOrUpdate
  dict.AddOrUpdate(
      key: 1,
      addValue: "one",
      updateValueFactory: (key, oldValue) => oldValue.ToUpper()
  );
  
  // GetOrAdd
  var value = dict.GetOrAdd(2, key => $"Value for {key}");
  
  // Atomic operations
  dict.AddOrUpdate(1, 1, (key, oldValue) => oldValue + 1);  // Increment

CONCURRENT QUEUE:
  var queue = new ConcurrentQueue<int>();
  
  queue.Enqueue(1);
  queue.Enqueue(2);
  
  if (queue.TryDequeue(out var item)) {
      Console.WriteLine(item);  // 1 (FIFO)
  }
  
  if (queue.TryPeek(out var peeked)) {
      Console.WriteLine(peeked);  // 2 (doesn't remove)
  }

CONCURRENT STACK:
  var stack = new ConcurrentStack<int>();
  
  stack.Push(1);
  stack.Push(2);
  
  if (stack.TryPop(out var item)) {
      Console.WriteLine(item);  // 2 (LIFO)
  }

CONCURRENT BAG:
  // Unordered collection, optimized for same thread adding/removing
  var bag = new ConcurrentBag<int>();
  
  bag.Add(1);
  bag.Add(2);
  
  if (bag.TryTake(out var item)) {
      Console.WriteLine(item);  // No guaranteed order
  }

BLOCKING COLLECTION:
  // Producer-consumer pattern with blocking
  var queue = new BlockingCollection<int>(boundedCapacity: 10);
  
  // Producer
  Task.Run(() => {
      for (int i = 0; i < 100; i++) {
          queue.Add(i);  // Blocks if full
      }
      queue.CompleteAdding();
  });
  
  // Consumer
  Task.Run(() => {
      foreach (var item in queue.GetConsumingEnumerable()) {
          Console.WriteLine(item);  // Blocks if empty
      }
  });

WHEN TO USE:
  • ConcurrentDictionary: Shared cache, lookup tables
  • ConcurrentQueue: Task queues, message passing
  • ConcurrentStack: Resource pools
  • ConcurrentBag: Parallel aggregation
  • BlockingCollection: Producer-consumer patterns

PERFORMANCE NOTES:
  • Not always faster than lock + standard collection
  • Profile to determine best choice
  • Optimized for specific scenarios

EXAMPLE FILE: Async/ThreadSafeCollectionsExample.cs

===============================================================================
PART 8: .NET FRAMEWORK CONCEPTS
===============================================================================

Understanding core .NET concepts is essential for effective development.

-------------------------------------------------------------------------------
8.1 .NET EVOLUTION
-------------------------------------------------------------------------------

.NET FRAMEWORK (Legacy):
  • Windows-only
  • First released in 2002
  • Monolithic
  • Latest: .NET Framework 4.8.1 (maintenance mode)
  • Used for: Legacy Windows applications, WCF, WPF, WinForms

.NET CORE (Superseded):
  • Cross-platform (Windows, Linux, macOS)
  • First released in 2016
  • Modular, open-source
  • High performance
  • Version: .NET Core 1.0 - 3.1

.NET 5+ (Current):
  • Unified platform (replaces both Framework and Core)
  • Started with .NET 5 (skipped 4 to avoid confusion with Framework 4.x)
  • Annual releases (November each year)
  • LTS (Long-Term Support) every other release
  • Current: .NET 9 (November 2024)
  • Next LTS: .NET 10 (November 2025)

VERSION HISTORY:
  • .NET Core 1.0 (2016) - Initial cross-platform release
  • .NET Core 2.0 (2017) - .NET Standard 2.0
  • .NET Core 3.0/3.1 (2019) - LTS, Windows Desktop support
  • .NET 5 (2020) - Unification begins
  • .NET 6 (2021) - LTS, Minimal APIs
  • .NET 7 (2022) - Performance improvements
  • .NET 8 (2023) - LTS, Native AOT
  • .NET 9 (2024) - Current release

TARGET FRAMEWORK MONIKERS (TFM):
  • net48: .NET Framework 4.8
  • netcoreapp3.1: .NET Core 3.1
  • net5.0, net6.0, net7.0, net8.0, net9.0: Modern .NET
  • netstandard2.0: .NET Standard (for libraries)

EXAMPLE FILE: Learning/DotNetConcepts/FrameworkVersions.md

-------------------------------------------------------------------------------
8.2 DEPENDENCY INJECTION
-------------------------------------------------------------------------------

PURPOSE:
  Inversion of Control (IoC) pattern. Dependencies are provided to objects
  rather than objects creating them.

BUILT-IN DI CONTAINER:
  .NET has built-in DI starting with .NET Core. No need for third-party
  containers in most cases.

SERVICE LIFETIMES:
  • Transient: Created each time requested (AddTransient)
  • Scoped: Created once per request/scope (AddScoped)
  • Singleton: Created once for application lifetime (AddSingleton)

EXAMPLE:
  // Service interface and implementation
  public interface IEmailService {
      Task SendAsync(string to, string subject, string body);
  }
  
  public class EmailService : IEmailService {
      private readonly ILogger<EmailService> _logger;
      
      public EmailService(ILogger<EmailService> logger) {
          _logger = logger;
      }
      
      public async Task SendAsync(string to, string subject, string body) {
          _logger.LogInformation("Sending email to {To}", to);
          // Send email...
      }
  }
  
  // Registration (Program.cs)
  var builder = WebApplication.CreateBuilder(args);
  
  builder.Services.AddTransient<IEmailService, EmailService>();  // New instance each time
  builder.Services.AddScoped<IOrderService, OrderService>();      // One per HTTP request
  builder.Services.AddSingleton<ICacheService, CacheService>();   // One for entire app
  
  var app = builder.Build();
  
  // Usage (injected via constructor)
  public class OrderController : ControllerBase {
      private readonly IEmailService _emailService;
      private readonly IOrderService _orderService;
      
      public OrderController(IEmailService emailService, IOrderService orderService) {
          _emailService = emailService;
          _orderService = orderService;
      }
      
      [HttpPost]
      public async Task<IActionResult> CreateOrder(CreateOrderRequest request) {
          var order = await _orderService.CreateAsync(request);
          await _emailService.SendAsync(request.Email, "Order Confirmed", $"Order #{order.Id}");
          return Ok(order);
      }
  }

WHEN TO USE EACH LIFETIME:
  • Transient:
    - Lightweight, stateless services
    - Services that should not be shared
    - Factory services
  
  • Scoped:
    - Database contexts (EF Core DbContext)
    - Repository pattern
    - Per-request services (HTTP request in web apps)
  
  • Singleton:
    - Configuration
    - Logging
    - Caching
    - Thread-safe stateless services

CAUTIONS:
  • Don't inject scoped service into singleton (captive dependency)
  • Don't inject transient into singleton (lifecycle mismatch)
  • Thread-safety required for singleton services
  • Dispose called automatically for disposable services

OPTIONS PATTERN:
  // appsettings.json
  {
    "Email": {
      "SmtpServer": "smtp.example.com",
      "Port": 587
    }
  }
  
  // Options class
  public class EmailOptions {
      public string SmtpServer { get; set; } = "";
      public int Port { get; set; }
  }
  
  // Registration
  builder.Services.Configure<EmailOptions>(
      builder.Configuration.GetSection("Email"));
  
  // Usage
  public class EmailService {
      private readonly EmailOptions _options;
      
      public EmailService(IOptions<EmailOptions> options) {
          _options = options.Value;
      }
  }

EXAMPLE FILE: Learning/DotNetConcepts/DependencyInjectionDemo.cs

-------------------------------------------------------------------------------
8.3 MIDDLEWARE (ASP.NET CORE)
-------------------------------------------------------------------------------

DEFINITION:
  Software components assembled into an application pipeline to handle requests
  and responses.

HOW IT WORKS:
  Each middleware component:
  1. Performs operations before passing request to next middleware
  2. Can short-circuit pipeline (not call next)
  3. Performs operations after next middleware returns

PIPELINE:
  Request → [Middleware 1] → [Middleware 2] → [Middleware 3] → Response
            ↓ ↑              ↓ ↑              ↓ ↑
            Process          Process          Process

BUILT-IN MIDDLEWARE:
  • UseStaticFiles: Serves static files
  • UseRouting: Adds route matching
  • UseAuthentication: Adds authentication
  • UseAuthorization: Adds authorization
  • UseEndpoints: Adds endpoint execution

CUSTOM MIDDLEWARE:
  // Middleware class
  public class RequestLoggingMiddleware {
      private readonly RequestDelegate _next;
      private readonly ILogger<RequestLoggingMiddleware> _logger;
      
      public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger) {
          _next = next;
          _logger = logger;
      }
      
      public async Task InvokeAsync(HttpContext context) {
          _logger.LogInformation("Request: {Method} {Path}", 
              context.Request.Method, context.Request.Path);
          
          await _next(context);  // Call next middleware
          
          _logger.LogInformation("Response: {StatusCode}", 
              context.Response.StatusCode);
      }
  }
  
  // Registration
  app.UseMiddleware<RequestLoggingMiddleware>();
  
  // Or extension method
  public static class MiddlewareExtensions {
      public static IApplicationBuilder UseRequestLogging(this IApplicationBuilder builder) {
          return builder.UseMiddleware<RequestLoggingMiddleware>();
      }
  }
  
  // Usage
  app.UseRequestLogging();

INLINE MIDDLEWARE:
  app.Use(async (context, next) => {
      // Before
      Console.WriteLine($"Request: {context.Request.Path}");
      
      await next();  // Call next middleware
      
      // After
      Console.WriteLine($"Response: {context.Response.StatusCode}");
  });

TERMINAL MIDDLEWARE (Short-circuit):
  app.Run(async context => {
      await context.Response.WriteAsync("Hello World!");
      // Pipeline ends here - next not called
  });

ORDER MATTERS:
  var app = builder.Build();
  
  app.UseStaticFiles();         // 1. Static files first
  app.UseRouting();             // 2. Routing
  app.UseAuthentication();      // 3. Authentication before authorization
  app.UseAuthorization();       // 4. Authorization
  app.MapControllers();         // 5. Endpoints last
  
  app.Run();

COMMON MIDDLEWARE SCENARIOS:
  • Logging
  • Exception handling
  • Authentication/Authorization
  • Request/Response modification
  • Caching
  • Compression
  • CORS

EXAMPLE FILE: Learning/WebAPI/Middleware/MiddlewareBestPractices.cs

-------------------------------------------------------------------------------
8.4 IQUERYABLE VS IENUMERABLE
-------------------------------------------------------------------------------

IENUMERABLE<T>:
  • In-memory collection interface
  • LINQ to Objects
  • Executes immediately or uses deferred execution in memory
  • Query executed in memory (client-side)

IQUERYABLE<T>:
  • Extends IEnumerable<T>
  • Used for external data sources (databases)
  • LINQ to SQL, Entity Framework
  • Query translated to data source query language (e.g., SQL)
  • Deferred execution at the data source (server-side)

KEY DIFFERENCE:
  IEnumerable: Executes query in application memory
  IQueryable: Builds expression tree, executes at data source

EXAMPLE:
  // IQueryable - filters at database
  IQueryable<Customer> query = dbContext.Customers
      .Where(c => c.IsActive)           // Translated to SQL WHERE
      .OrderBy(c => c.Name);             // Translated to SQL ORDER BY
  
  var customers = query.ToList();       // SQL executed here
  // SQL: SELECT * FROM Customers WHERE IsActive = 1 ORDER BY Name
  
  // IEnumerable - filters in memory
  IEnumerable<Customer> allCustomers = dbContext.Customers.ToList();  // Fetch ALL
  var activeCustomers = allCustomers
      .Where(c => c.IsActive)           // Filtered in memory (C#)
      .OrderBy(c => c.Name);             // Sorted in memory (C#)
  // SQL: SELECT * FROM Customers (fetches everything!)

WHEN TO USE:
  • IQueryable: Database queries, external data sources
    - Filtering at database (performance)
    - Paging, sorting at database
    - Complex queries that should run server-side
  
  • IEnumerable: In-memory collections
    - List, Array operations
    - After data is already fetched
    - Complex C# logic that can't translate to SQL

COMPOSITION:
  // IQueryable allows query composition before execution
  IQueryable<Customer> query = dbContext.Customers.Where(c => c.IsActive);
  
  if (searchText != null) {
      query = query.Where(c => c.Name.Contains(searchText));  // Adds to SQL
  }
  
  if (sortByName) {
      query = query.OrderBy(c => c.Name);  // Adds to SQL
  }
  
  var results = query.ToList();  // Single SQL query with all filters

ASQUERYBALE VS ASENUMERABLE:
  // Force switch from IQueryable to IEnumerable
  var query = dbContext.Customers
      .Where(c => c.IsActive)            // SQL
      .AsEnumerable()                    // Switch to in-memory
      .Where(c => MyComplexMethod(c));   // C# method (can't translate to SQL)

PERFORMANCE:
  // BAD: Fetches all data then filters
  var customers = dbContext.Customers.ToList()
      .Where(c => c.IsActive)
      .Take(10);
  // SQL: SELECT * FROM Customers (fetches millions of rows!)
  
  // GOOD: Filters and takes at database
  var customers = dbContext.Customers
      .Where(c => c.IsActive)
      .Take(10)
      .ToList();
  // SQL: SELECT TOP 10 * FROM Customers WHERE IsActive = 1

EXAMPLE FILE: Learning/LINQAndQueries/IQueryableVsIEnumerable.cs

-------------------------------------------------------------------------------
8.5 LINQ (LANGUAGE INTEGRATED QUERY)
-------------------------------------------------------------------------------

PURPOSE:
  Provides query capabilities directly in C#. Unified syntax for querying
  different data sources.

QUERY SYNTAX vs METHOD SYNTAX:
  // Query syntax (SQL-like)
  var query = from c in customers
              where c.IsActive
              orderby c.Name
              select c;
  
  // Method syntax (fluent)
  var query = customers
      .Where(c => c.IsActive)
      .OrderBy(c => c.Name);

COMMON OPERATORS:
  // Filtering
  Where()             // Filter elements
  OfType<T>()         // Filter by type
  
  // Projection
  Select()            // Transform each element
  SelectMany()        // Flatten nested collections
  
  // Sorting
  OrderBy()           // Sort ascending
  OrderByDescending() // Sort descending
  ThenBy()            // Secondary sort
  
  // Grouping
  GroupBy()           // Group elements
  
  // Aggregation
  Count()             // Count elements
  Sum()               // Sum values
  Average()           // Average value
  Min()               // Minimum value
  Max()               // Maximum value
  Aggregate()         // Custom aggregation
  
  // Quantifiers
  Any()               // At least one element matches
  All()               // All elements match
  Contains()          // Contains specific element
  
  // Set operations
  Distinct()          // Remove duplicates
  Union()             // Set union
  Intersect()         // Set intersection
  Except()            // Set difference
  
  // Element operations
  First()             // First element (throws if none)
  FirstOrDefault()    // First element (null if none)  Last()              // Last element
  Single()            // Only element (throws if 0 or >1)
  
  // Partitioning
  Take()              // Take first N elements
  Skip()              // Skip first N elements
  TakeLast()          // Take last N elements
  SkipLast()          // Skip last N elements
  
  // Joins
  Join()              // Inner join
  GroupJoin()         // Group join (left outer join)

EXAMPLES:
  var customers = new List<Customer> { /* ... */ };
  
  // Where - filtering
  var activeCustomers = customers.Where(c => c.IsActive);
  
  // Select - projection
  var names = customers.Select(c => c.Name);
  var dtos = customers.Select(c => new { c.Id, c.Name });
  
  // SelectMany - flattening
  var allOrders = customers.SelectMany(c => c.Orders);
  
  // OrderBy
  var sorted = customers.OrderBy(c => c.Name).ThenBy(c => c.Age);
  
  // GroupBy
  var grouped = customers.GroupBy(c => c.City);
  foreach (var group in grouped) {
      Console.WriteLine($"{group.Key}: {group.Count()} customers");
  }
  
  // Aggregation
  var totalRevenue = orders.Sum(o => o.Total);
  var averageAge = customers.Average(c => c.Age);
  var oldestCustomer = customers.Max(c => c.Age);
  
  // Any/All
  bool hasActiveCustomers = customers.Any(c => c.IsActive);
  bool allActive = customers.All(c => c.IsActive);
  
  // Paging
  var page = customers
      .OrderBy(c => c.Name)
      .Skip((pageNumber - 1) * pageSize)
      .Take(pageSize);
  
  // Join
  var query = customers
      .Join(orders,
          customer => customer.Id,
          order => order.CustomerId,
          (customer, order) => new { customer.Name, order.Total });

DEFERRED EXECUTION:
  // Query defined but not executed
  var query = customers.Where(c => c.IsActive);
  
  // Executed when enumerated
  foreach (var customer in query) { }  // Executes here
  var list = query.ToList();           // Or here
  var count = query.Count();           // Or here

IMMEDIATE EXECUTION:
  // These execute immediately
  ToList(), ToArray(), ToDictionary(), ToHashSet()
  Count(), Sum(), Average(), Min(), Max()
  First(), Single(), Last()

EXAMPLE FILE: Learning/LINQAndQueries/LINQExamples.cs

-------------------------------------------------------------------------------
8.6 ENTITY FRAMEWORK CORE
-------------------------------------------------------------------------------

PURPOSE:
  Object-Relational Mapper (ORM) for .NET. Maps classes to database tables,
  translating LINQ queries to SQL.

DB CONTEXT:
  public class AppDbContext : DbContext {
      public DbSet<Customer> Customers { get; set; } = null!;
      public DbSet<Order> Orders { get; set; } = null!;
      
      protected override void OnConfiguring(DbContextOptionsBuilder options) {
          options.UseSqlServer("connection string");
      }
      
      protected override void OnModelCreating(ModelBuilder modelBuilder) {
          // Fluent API configuration
          modelBuilder.Entity<Customer>()
              .HasMany(c => c.Orders)
              .WithOne(o => o.Customer)
              .HasForeignKey(o => o.CustomerId);
      }
  }

CRUD OPERATIONS:
  // Create
  var customer = new Customer { Name = "John", Email = "john@example.com" };
  dbContext.Customers.Add(customer);
  await dbContext.SaveChangesAsync();
  
  // Read
  var customer = await dbContext.Customers.FindAsync(id);
  var activeCustomers = await dbContext.Customers
      .Where(c => c.IsActive)
      .ToListAsync();
  
  // Update
  var customer = await dbContext.Customers.FindAsync(id);
  customer.Name = "Jane";
  await dbContext.SaveChangesAsync();
  
  // Delete
  var customer = await dbContext.Customers.FindAsync(id);
  dbContext.Customers.Remove(customer);
  await dbContext.SaveChangesAsync();

TRACKING:
  // Tracked (default for queries)
  var customer = await dbContext.Customers.FindAsync(id);
  customer.Name = "Updated";
  await dbContext.SaveChangesAsync();  // EF detects changes
  
  // No tracking (read-only, better performance)
  var customers = await dbContext.Customers
      .AsNoTracking()
      .ToListAsync();

EAGER LOADING (Include):
  // Load related data
  var customers = await dbContext.Customers
      .Include(c => c.Orders)
      .ThenInclude(o => o.Items)
      .ToListAsync();

LAZY LOADING:
  // Requires proxies and virtual navigation properties
  public class Customer {
      public int Id { get; set; }
      public virtual ICollection<Order> Orders { get; set; }  // virtual!
  }
  
  // Orders loaded automatically when accessed
  var orders = customer.Orders;  // Database query happens here

EXPLICIT LOADING:
  var customer = await dbContext.Customers.FindAsync(id);
  await dbContext.Entry(customer)
      .Collection(c => c.Orders)
      .LoadAsync();

MIGRATIONS:
  // Add migration
  dotnet ef migrations add InitialCreate
  
  // Update database
  dotnet ef database update
  
  // Rollback
  dotnet ef database update PreviousMigration

BEST PRACTICES:
  • Use AsNoTracking for read-only queries
  • Don't fetch more data than needed (projection)
  • Be explicit with Include (avoid lazy loading performance issues)
  • Use async methods (ToListAsync, SaveChangesAsync)
  • Dispose DbContext (use using or DI with scoped lifetime)
  • Don't track entities you won't update

EXAMPLE FILE: Learning/DataAccess/EntityFramework/EntityFrameworkBestPractices.cs

-------------------------------------------------------------------------------
8.6.1 ENTITY FRAMEWORK - CHANGE TRACKING
-------------------------------------------------------------------------------

WHAT IS CHANGE TRACKING?
  EF Core tracks changes to entities loaded from the database. When you call
  SaveChangesAsync(), EF detects what changed and generates appropriate SQL
  (INSERT, UPDATE, DELETE).

HOW IT WORKS:
  When you load an entity, EF creates a "snapshot" of its original values.
  When SaveChangesAsync() is called, EF compares current values with the
  snapshot to detect changes.

ENTITY STATES:
  • Unchanged: Loaded from database, not modified
  • Added: New entity, will be inserted
  • Modified: Loaded from database and modified
  • Deleted: Marked for deletion
  • Detached: Not tracked by context

CHECKING ENTITY STATE:
  var customer = await dbContext.Customers.FindAsync(id);
  var state = dbContext.Entry(customer).State;  // EntityState.Unchanged
  
  customer.Name = "Updated";
  state = dbContext.Entry(customer).State;  // EntityState.Modified
  
  // View all tracked entities
  var entries = dbContext.ChangeTracker.Entries()
      .Where(e => e.State != EntityState.Unchanged)
      .ToList();

DISABLING TRACKING:
  // Query-level (best for read-only queries)
  var customers = await dbContext.Customers
      .AsNoTracking()
      .ToListAsync();
  
  // Context-level (all queries)
  dbContext.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
  
  // Re-enable for specific query
  var tracked = await dbContext.Customers
      .AsTracking()
      .FirstOrDefaultAsync(c => c.Id == id);

MANUAL STATE MANAGEMENT:
  // Attach entity and mark as modified
  var customer = new Customer { Id = 1, Name = "Updated" };
  dbContext.Customers.Attach(customer);
  dbContext.Entry(customer).State = EntityState.Modified;
  await dbContext.SaveChangesAsync();
  
  // Mark specific properties as modified
  dbContext.Customers.Attach(customer);
  dbContext.Entry(customer).Property(c => c.Name).IsModified = true;
  await dbContext.SaveChangesAsync();

DISCONNECTED SCENARIOS:
  // Web API: Entity comes from client, not tracked
  [HttpPut("{id}")]
  public async Task<IActionResult> Update(int id, Customer customer) {
      if (id != customer.Id) return BadRequest();
      
      // Attach and mark as modified
      dbContext.Entry(customer).State = EntityState.Modified;
      
      try {
          await dbContext.SaveChangesAsync();
          return NoContent();
      }
      catch (DbUpdateConcurrencyException) {
          // Handle concurrency conflict
          return Conflict();
      }
  }

CHANGE TRACKER EVENTS:
  dbContext.ChangeTracker.Tracked += (sender, args) => {
      Console.WriteLine($"Entity {args.Entry.Entity.GetType().Name} is now tracked");
  };
  
  dbContext.ChangeTracker.StateChanged += (sender, args) => {
      Console.WriteLine($"Entity state changed from {args.OldState} to {args.NewState}");
  };

DETECTING CHANGES MANUALLY:
  // Force EF to detect changes (automatic by default before SaveChanges)
  dbContext.ChangeTracker.DetectChanges();
  
  // Disable automatic detection (performance optimization)
  dbContext.ChangeTracker.AutoDetectChangesEnabled = false;
  
  // Bulk operations
  for (int i = 0; i < 1000; i++) {
      dbContext.Products.Add(new Product { Name = $"Product {i}" });
  }
  dbContext.ChangeTracker.DetectChanges();  // Single detection
  await dbContext.SaveChangesAsync();
  
  dbContext.ChangeTracker.AutoDetectChangesEnabled = true;  // Re-enable

PERFORMANCE CONSIDERATIONS:
  // BAD: Tracking entities you won't modify
  var customers = await dbContext.Customers.ToListAsync();  // All tracked
  return customers.Select(c => new CustomerDto { 
      Id = c.Id, 
      Name = c.Name 
  });
  
  // GOOD: No tracking for read-only
  var customers = await dbContext.Customers
      .AsNoTracking()
      .Select(c => new CustomerDto { Id = c.Id, Name = c.Name })
      .ToListAsync();

WHEN TO USE NO TRACKING:
  ✅ Read-only queries
  ✅ Reporting and analytics
  ✅ API GET endpoints that return data
  ✅ Large result sets
  
  ❌ When you need to update entities
  ❌ When you need navigation property loading
  ❌ When you're updating entities immediately after loading

BEST PRACTICES:
  • Use AsNoTracking() for all read-only queries
  • Understand entity states for disconnected scenarios
  • Disable automatic change detection for bulk operations
  • Use change tracker events for auditing
  • Be explicit about tracking behavior
  • Don't track more entities than necessary

EXAMPLE FILE: Learning/DataAccess/EntityFramework/ChangeTrackingExamples.cs

-------------------------------------------------------------------------------
8.6.2 ENTITY FRAMEWORK - RELATIONSHIPS & NAVIGATION PROPERTIES
-------------------------------------------------------------------------------

RELATIONSHIP TYPES:
  • One-to-Many: Customer → Orders
  • One-to-One: User → UserProfile
  • Many-to-Many: Students ↔ Courses

ONE-TO-MANY RELATIONSHIP:
  // Principal (parent)
  public class Customer {
      public int Id { get; set; }
      public string Name { get; set; }
      
      // Navigation property (collection)
      public ICollection<Order> Orders { get; set; } = new List<Order>();
  }
  
  // Dependent (child)
  public class Order {
      public int Id { get; set; }
      public DateTime OrderDate { get; set; }
      
      // Foreign key
      public int CustomerId { get; set; }
      
      // Navigation property (reference)
      public Customer Customer { get; set; } = null!;
  }
  
  // Configuration (optional, conventions handle this)
  protected override void OnModelCreating(ModelBuilder modelBuilder) {
      modelBuilder.Entity<Customer>()
          .HasMany(c => c.Orders)
          .WithOne(o => o.Customer)
          .HasForeignKey(o => o.CustomerId)
          .OnDelete(DeleteBehavior.Cascade);  // Delete orders when customer deleted
  }

ONE-TO-ONE RELATIONSHIP:
  public class User {
      public int Id { get; set; }
      public string Username { get; set; }
      
      // Navigation property
      public UserProfile Profile { get; set; } = null!;
  }
  
  public class UserProfile {
      public int Id { get; set; }
      public string Bio { get; set; }
      public string Avatar { get; set; }
      
      // Foreign key (same as primary key)
      public int UserId { get; set; }
      
      // Navigation property
      public User User { get; set; } = null!;
  }
  
  // Configuration
  modelBuilder.Entity<User>()
      .HasOne(u => u.Profile)
      .WithOne(p => p.User)
      .HasForeignKey<UserProfile>(p => p.UserId);

MANY-TO-MANY RELATIONSHIP (EF Core 5+):
  // EF Core automatically creates join table
  public class Student {
      public int Id { get; set; }
      public string Name { get; set; }
      
      public ICollection<Course> Courses { get; set; } = new List<Course>();
  }
  
  public class Course {
      public int Id { get; set; }
      public string Title { get; set; }
      
      public ICollection<Student> Students { get; set; } = new List<Student>();
  }
  
  // Configuration (optional)
  modelBuilder.Entity<Student>()
      .HasMany(s => s.Courses)
      .WithMany(c => c.Students)
      .UsingEntity(j => j.ToTable("StudentCourses"));  // Custom table name

MANY-TO-MANY WITH PAYLOAD:
  // Need explicit join entity when join table has extra columns
  public class StudentCourse {
      public int StudentId { get; set; }
      public Student Student { get; set; } = null!;
      
      public int CourseId { get; set; }
      public Course Course { get; set; } = null!;
      
      // Additional properties
      public DateTime EnrollmentDate { get; set; }
      public int Grade { get; set; }
  }
  
  public class Student {
      public int Id { get; set; }
      public string Name { get; set; }
      public ICollection<StudentCourse> StudentCourses { get; set; } = new List<StudentCourse>();
  }
  
  public class Course {
      public int Id { get; set; }
      public string Title { get; set; }
      public ICollection<StudentCourse> StudentCourses { get; set; } = new List<StudentCourse>();
  }
  
  // Configuration
  modelBuilder.Entity<StudentCourse>()
      .HasKey(sc => new { sc.StudentId, sc.CourseId });  // Composite key

LOADING STRATEGIES:
  
  1. EAGER LOADING (Load with Include):
     // Load customer with orders
     var customer = await dbContext.Customers
         .Include(c => c.Orders)
         .FirstOrDefaultAsync(c => c.Id == id);
     
     // Multiple levels
     var customer = await dbContext.Customers
         .Include(c => c.Orders)
             .ThenInclude(o => o.Items)
         .Include(c => c.Address)
         .FirstOrDefaultAsync(c => c.Id == id);
     
     // Filtered include (EF Core 5+)
     var customer = await dbContext.Customers
         .Include(c => c.Orders.Where(o => o.OrderDate >= DateTime.UtcNow.AddMonths(-1)))
         .FirstOrDefaultAsync(c => c.Id == id);
  
  2. EXPLICIT LOADING:
     var customer = await dbContext.Customers.FindAsync(id);
     
     // Load collection
     await dbContext.Entry(customer)
         .Collection(c => c.Orders)
         .LoadAsync();
     
     // Load reference
     await dbContext.Entry(order)
         .Reference(o => o.Customer)
         .LoadAsync();
     
     // Load with filter
     await dbContext.Entry(customer)
         .Collection(c => c.Orders)
         .Query()
         .Where(o => o.Total > 100)
         .LoadAsync();
  
  3. LAZY LOADING (Not recommended):
     // Requires:
     // 1. Microsoft.EntityFrameworkCore.Proxies package
     // 2. Virtual navigation properties
     // 3. UseLazyLoadingProxies() in configuration
     
     builder.Services.AddDbContext<AppDbContext>(options =>
         options.UseSqlServer(connectionString)
                .UseLazyLoadingProxies());
     
     public class Customer {
         public virtual ICollection<Order> Orders { get; set; }  // virtual!
     }
     
     // Orders loaded automatically when accessed
     var customer = await dbContext.Customers.FindAsync(id);
     var orders = customer.Orders;  // Database query happens here
     
     // CAUTION: Can cause N+1 query problems!

SELECT LOADING (Projection):
  // Best for performance - only load what you need
  var customerDto = await dbContext.Customers
      .Where(c => c.Id == id)
      .Select(c => new CustomerDto {
          Id = c.Id,
          Name = c.Name,
          TotalOrders = c.Orders.Count,
          RecentOrders = c.Orders
              .OrderByDescending(o => o.OrderDate)
              .Take(5)
              .Select(o => new OrderDto { Id = o.Id, Total = o.Total })
              .ToList()
      })
      .FirstOrDefaultAsync();

CASCADE BEHAVIOR:
  • Cascade: Delete dependent entities when principal deleted
  • Restrict: Prevent deletion if dependents exist
  • SetNull: Set foreign key to null when principal deleted
  • NoAction: Database handles deletion
  
  modelBuilder.Entity<Customer>()
      .HasMany(c => c.Orders)
      .WithOne(o => o.Customer)
      .OnDelete(DeleteBehavior.Cascade);  // Delete orders with customer

NAVIGATION PROPERTY BEST PRACTICES:
  • Always initialize collections (= new List<>())
  • Use Include sparingly (performance cost)
  • Prefer Select (projection) over Include when possible
  • Avoid lazy loading (N+1 query problems)
  • Use filtered includes in EF Core 5+
  • Be explicit about loading strategy
  • Profile queries to understand performance

COMMON PATTERNS:
  // Load parent with filtered children
  var customers = await dbContext.Customers
      .Include(c => c.Orders.Where(o => o.Total > 100))
      .ToListAsync();
  
  // Load specific navigation property later
  if (includeOrders) {
      await dbContext.Entry(customer)
          .Collection(c => c.Orders)
          .LoadAsync();
  }
  
  // Check if navigation property is loaded
  bool isLoaded = dbContext.Entry(customer)
      .Collection(c => c.Orders)
      .IsLoaded;

EXAMPLE FILE: Learning/DataAccess/EntityFramework/RelationshipsNavigationExamples.cs

-------------------------------------------------------------------------------
8.6.3 ENTITY FRAMEWORK - MIGRATIONS IN DEPTH
-------------------------------------------------------------------------------

WHAT ARE MIGRATIONS?
  Version control for your database schema. Migrations track changes to your
  model and update the database schema accordingly.

CREATING MIGRATIONS:
  // Add new migration
  dotnet ef migrations add InitialCreate
  dotnet ef migrations add AddCustomerEmail
  
  // With specific context (if multiple contexts)
  dotnet ef migrations add InitialCreate --context AppDbContext
  
  // Specify output directory
  dotnet ef migrations add InitialCreate --output-dir Data/Migrations

MIGRATION FILE STRUCTURE:
  // 20240213120000_InitialCreate.cs
  public partial class InitialCreate : Migration {
      protected override void Up(MigrationBuilder migrationBuilder) {
          // Code to apply migration (create tables, columns, etc.)
          migrationBuilder.CreateTable(
              name: "Customers",
              columns: table => new {
                  Id = table.Column<int>(nullable: false)
                      .Annotation("SqlServer:Identity", "1, 1"),
                  Name = table.Column<string>(maxLength: 100, nullable: false),
                  Email = table.Column<string>(nullable: true)
              },
              constraints: table => {
                  table.PrimaryKey("PK_Customers", x => x.Id);
              });
      }
      
      protected override void Down(MigrationBuilder migrationBuilder) {
          // Code to revert migration (rollback)
          migrationBuilder.DropTable(name: "Customers");
      }
  }

APPLYING MIGRATIONS:
  // Update to latest migration
  dotnet ef database update
  
  // Update to specific migration
  dotnet ef database update AddCustomerEmail
  
  // Rollback all migrations (empty database)
  dotnet ef database update 0
  
  // Generate SQL script without applying
  dotnet ef migrations script
  
  // Script from specific migration to another
  dotnet ef migrations script InitialCreate AddCustomerEmail

REMOVING MIGRATIONS:
  // Remove last migration (if not applied to database)
  dotnet ef migrations remove
  
  // If already applied, rollback first
  dotnet ef database update PreviousMigration
  dotnet ef migrations remove

MIGRATION BUNDLE (EF Core 6+):
  // Create executable that applies migrations
  dotnet ef migrations bundle
  
  // Run bundle
  ./efbundle --connection "Server=..."
  
  // Useful for deployment scenarios

SEEDING DATA IN MIGRATIONS:
  protected override void Up(MigrationBuilder migrationBuilder) {
      migrationBuilder.InsertData(
          table: "Customers",
          columns: new[] { "Id", "Name", "Email" },
          values: new object[,] {
              { 1, "John Doe", "john@example.com" },
              { 2, "Jane Smith", "jane@example.com" }
          });
  }
  
  // Better: Use HasData in OnModelCreating
  modelBuilder.Entity<Customer>().HasData(
      new Customer { Id = 1, Name = "John Doe", Email = "john@example.com" },
      new Customer { Id = 2, Name = "Jane Smith", Email = "jane@example.com" }
  );

CUSTOM MIGRATION OPERATIONS:
  protected override void Up(MigrationBuilder migrationBuilder) {
      // Execute raw SQL
      migrationBuilder.Sql(@"
          CREATE INDEX IX_Customers_Email 
          ON Customers(Email) 
          WHERE Email IS NOT NULL
      ");
      
      // Create stored procedure
      migrationBuilder.Sql(@"
          CREATE PROCEDURE GetCustomerOrders
              @CustomerId INT
          AS
          BEGIN
              SELECT * FROM Orders WHERE CustomerId = @CustomerId
          END
      ");
  }

MIGRATION CONFIGURATION:
  protected override void OnModelCreating(ModelBuilder modelBuilder) {
      // Table name
      modelBuilder.Entity<Customer>().ToTable("Customers");
      
      // Column configuration
      modelBuilder.Entity<Customer>()
          .Property(c => c.Name)
          .HasColumnName("CustomerName")
          .HasColumnType("varchar(100)")
          .IsRequired();
      
      // Index
      modelBuilder.Entity<Customer>()
          .HasIndex(c => c.Email)
          .IsUnique();
      
      // Composite index
      modelBuilder.Entity<Order>()
          .HasIndex(o => new { o.CustomerId, o.OrderDate });
      
      // Check constraint
      modelBuilder.Entity<Product>()
          .HasCheckConstraint("CK_Product_Price", "Price > 0");
      
      // Default value
      modelBuilder.Entity<Order>()
          .Property(o => o.OrderDate)
          .HasDefaultValueSql("GETUTCDATE()");
      
      // Computed column
      modelBuilder.Entity<Order>()
          .Property(o => o.Total)
          .HasComputedColumnSql("Subtotal + Tax");
  }

HANDLING PRODUCTION MIGRATIONS:
  1. GENERATE SCRIPTS:
     dotnet ef migrations script --idempotent --output migration.sql
     
     // Review SQL before applying
     // Apply through deployment pipeline
  
  2. MIGRATION BUNDLES:
     dotnet ef migrations bundle --self-contained
     
     // Deploy bundle with application
     // Run as part of deployment
  
  3. AUTOMATIC MIGRATION (Development only):
     // Program.cs
     using (var scope = app.Services.CreateScope()) {
         var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
         await dbContext.Database.MigrateAsync();  // Apply pending migrations
     }

BRANCHING STRATEGIES:
  // Merge conflicts with migrations
  // 1. Keep both migration files
  // 2. Create new "merge" migration to resolve conflicts
  
  dotnet ef migrations add MergeBranchConflicts

MIGRATION BEST PRACTICES:
  • ✅ Always review generated migration code
  • ✅ Test migrations on copy of production database
  • ✅ Use idempotent scripts for production
  • ✅ Keep migrations small and focused
  • ✅ Never edit applied migrations
  • ✅ Use migrations bundle or scripts for deployment
  • ✅ Back up database before applying migrations
  • ✅ Have rollback plan
  • ❌ Don't use automatic migrations in production
  • ❌ Don't delete migrations once applied
  • ❌ Don't modify Up() without modifying Down()

TROUBLESHOOTING:
  // Pending model changes
  dotnet ef migrations add FixModelChanges
  
  // Database out of sync
  // Option 1: Apply migrations
  dotnet ef database update
  
  // Option 2: Reset database (development only!)
  dotnet ef database drop
  dotnet ef database update
  
  // View migration history
  SELECT * FROM __EFMigrationsHistory

EXAMPLE FILE: Learning/DataAccess/EntityFramework/MigrationsInDepthExamples.cs

-------------------------------------------------------------------------------
8.6.4 ENTITY FRAMEWORK - PERFORMANCE OPTIMIZATION
-------------------------------------------------------------------------------

QUERY OPTIMIZATION:

1. PROJECTION (Select only needed columns):
   // BAD: Fetches all columns
   var customers = await dbContext.Customers.ToListAsync();
   
   // GOOD: Only needed columns
   var customers = await dbContext.Customers
       .Select(c => new { c.Id, c.Name, c.Email })
       .ToListAsync();

2. ASNOTRACKING (Read-only queries):
   // 30-40% faster for read-only queries
   var customers = await dbContext.Customers
       .AsNoTracking()
       .ToListAsync();

3. AVOID N+1 QUERIES:
   // BAD: N+1 queries (1 for customers + N for orders)
   var customers = await dbContext.Customers.ToListAsync();
   foreach (var customer in customers) {
       var orders = customer.Orders;  // Separate query each time!
   }
   
   // GOOD: Single query with Include
   var customers = await dbContext.Customers
       .Include(c => c.Orders)
       .ToListAsync();
   
   // BETTER: Select loading (projection)
   var customers = await dbContext.Customers
       .Select(c => new {
           c.Id,
           c.Name,
           OrderCount = c.Orders.Count,
           TotalSpent = c.Orders.Sum(o => o.Total)
       })
       .ToListAsync();

4. SPLIT QUERIES (Large includes):
   // Single query can be slow with multiple includes
   // BAD: Cartesian explosion
   var customers = await dbContext.Customers
       .Include(c => c.Orders)
       .Include(c => c.Addresses)
       .Include(c => c.Contacts)
       .ToListAsync();
   
   // GOOD: Split into multiple queries (EF Core 5+)
   var customers = await dbContext.Customers
       .Include(c => c.Orders)
       .Include(c => c.Addresses)
       .AsSplitQuery()  // Multiple SQL queries
       .ToListAsync();

5. COMPILED QUERIES:
   // Frequently executed queries
   private static readonly Func<AppDbContext, int, Task<Customer?>> GetCustomerById =
       EF.CompileAsyncQuery((AppDbContext db, int id) =>
           db.Customers
               .Include(c => c.Orders)
               .FirstOrDefault(c => c.Id == id));
   
   // Usage (compiled once, reused)
   var customer = await GetCustomerById(dbContext, customerId);

6. BATCH OPERATIONS:
   // BAD: Multiple round trips
   foreach (var customer in customers) {
       dbContext.Customers.Add(customer);
       await dbContext.SaveChangesAsync();  // Database call each iteration!
   }
   
   // GOOD: Single batch
   dbContext.Customers.AddRange(customers);
   await dbContext.SaveChangesAsync();  // Single database call
   
   // BETTER: Use EF Core Bulk Extensions for large batches
   await dbContext.BulkInsertAsync(customers);

7. PAGING:
   // Always page large result sets
   var customers = await dbContext.Customers
       .OrderBy(c => c.Id)
       .Skip((page - 1) * pageSize)
       .Take(pageSize)
       .ToListAsync();

8. FILTEREDINCLUDE (EF Core 5+):
   // Load only needed related data
   var customers = await dbContext.Customers
       .Include(c => c.Orders.Where(o => o.OrderDate >= DateTime.UtcNow.AddMonths(-3)))
       .ToListAsync();

INDEXING:
  protected override void OnModelCreating(ModelBuilder modelBuilder) {
      // Single column index
      modelBuilder.Entity<Customer>()
          .HasIndex(c => c.Email);
      
      // Unique index
      modelBuilder.Entity<Order>()
          .HasIndex(o => o.OrderNumber)
          .IsUnique();
      
      // Composite index
      modelBuilder.Entity<Order>()
          .HasIndex(o => new { o.CustomerId, o.OrderDate });
      
      // Filtered index (SQL Server)
      modelBuilder.Entity<Customer>()
          .HasIndex(c => c.Email)
          .HasFilter("Email IS NOT NULL");
  }

CONNECTION MANAGEMENT:
  // Use connection pooling (automatic in EF Core)
  // Configure pool size if needed
  builder.Services.AddDbContext<AppDbContext>(options =>
      options.UseSqlServer(connectionString, 
          sqlOptions => sqlOptions.MaxBatchSize(100)));
  
  // Use DbContext factory for long-running operations
  builder.Services.AddDbContextFactory<AppDbContext>(options =>
      options.UseSqlServer(connectionString));
  
  // Usage
  await using var dbContext = await _dbContextFactory.CreateDbContextAsync();

RAW SQL FOR COMPLEX QUERIES:
  // When LINQ translation is slow or complex
  var customers = await dbContext.Customers
      .FromSqlRaw(@"
          SELECT c.Id, c.Name, COUNT(o.Id) as OrderCount
          FROM Customers c
          LEFT JOIN Orders o ON c.Id = o.CustomerId
          GROUP BY c.Id, c.Name
          HAVING COUNT(o.Id) > 10
      ")
      .ToListAsync();
  
  // With parameters (prevents SQL injection)
  var customers = await dbContext.Customers
      .FromSqlInterpolated($@"
          SELECT * FROM Customers 
          WHERE Name LIKE {searchTerm + '%'}
      ")
      .ToListAsync();

STORED PROCEDURES:
  // Execute stored procedure
  var customerId = 1;
  var orders = await dbContext.Orders
      .FromSqlInterpolated($"EXEC GetCustomerOrders {customerId}")
      .ToListAsync();

QUERY TAGS (Debugging):
  // Add comment to generated SQL
  var customers = await dbContext.Customers
      .TagWith("GetActiveCustomers - Dashboard")
      .Where(c => c.IsActive)
      .ToListAsync();
  
  // Generated SQL includes: -- GetActiveCustomers - Dashboard

CACHING:
  // Application-level caching
  private readonly IMemoryCache _cache;
  
  public async Task<List<Product>> GetProductsAsync() {
      const string cacheKey = "products_all";
      
      if (!_cache.TryGetValue(cacheKey, out List<Product> products)) {
          products = await dbContext.Products
              .AsNoTracking()
              .ToListAsync();
          
          _cache.Set(cacheKey, products, TimeSpan.FromMinutes(10));
      }
      
      return products;
  }

MONITORING & PROFILING:
  // Log SQL queries (development)
  builder.Services.AddDbContext<AppDbContext>(options =>
      options.UseSqlServer(connectionString)
             .LogTo(Console.WriteLine, LogLevel.Information)
             .EnableSensitiveDataLogging()  // Logs parameter values
             .EnableDetailedErrors());
  
  // Production: Use interceptors
  public class QueryPerformanceInterceptor : DbCommandInterceptor {
      private readonly ILogger<QueryPerformanceInterceptor> _logger;
      
      public override async ValueTask<DbDataReader> ReaderExecutedAsync(
          DbCommand command,
          CommandExecutedEventData eventData,
          DbDataReader result,
          CancellationToken cancellationToken = default) {
          
          if (eventData.Duration.TotalMilliseconds > 1000) {
              _logger.LogWarning(
                  "Slow query detected: {Duration}ms - {CommandText}",
                  eventData.Duration.TotalMilliseconds,
                  command.CommandText);
          }
          
          return await base.ReaderExecutedAsync(command, eventData, result, cancellationToken);
      }
  }

PERFORMANCE CHECKLIST:
  ✅ Use AsNoTracking for read-only queries
  ✅ Project only needed columns (Select)
  ✅ Use Include judiciously (avoid over-fetching)
  ✅ Consider AsSplitQuery for multiple includes
  ✅ Use compiled queries for frequent queries
  ✅ Batch saves (AddRange vs multiple Add + Save)
  ✅ Always page large result sets
  ✅ Add indexes on frequently queried columns
  ✅ Use connection pooling
  ✅ Profile and monitor slow queries
  ✅ Consider raw SQL for complex queries
  ✅ Cache frequently accessed data
  ✅ Disable automatic change tracking for bulk operations

EXAMPLE FILE: Learning/DataAccess/EntityFramework/PerformanceOptimizationExamples.cs

-------------------------------------------------------------------------------
8.6.5 ENTITY FRAMEWORK - BEST PRACTICES & ANTI-PATTERNS
-------------------------------------------------------------------------------

PURPOSE: Common EF Core mistakes developers make and their proper solutions.
         Learning these patterns prevents most performance and correctness issues.

1. N+1 QUERY PROBLEM (MOST COMMON MISTAKE):

   ❌ BAD: Separate query for each entity
   var blogs = await dbContext.Blogs.ToListAsync();
   foreach (var blog in blogs) {
       var postCount = blog.Posts.Count;  // Separate SQL query each time!
       Console.WriteLine($"{blog.Name}: {postCount} posts");
   }
   // Problem: If 100 blogs, makes 101 database queries (1 + 100)
   // Impact: Massive performance hit, network latency multiplied

   ✅ GOOD: Single query with Include
   var blogs = await dbContext.Blogs
       .Include(b => b.Posts)
       .ToListAsync();
   foreach (var blog in blogs) {
       Console.WriteLine($"{blog.Name}: {blog.Posts.Count} posts");
   }
   // Benefit: Only 1 database query with JOIN
   // Performance: Can be 100x faster or more!

2. TRACKING OVERHEAD FOR READ-ONLY QUERIES:

   ❌ BAD: Default tracking when not updating
   var blogs = await dbContext.Blogs.ToListAsync();
   // Display blogs in UI (no updates needed)
   // Problem: EF Core tracks all entities (memory + CPU overhead)

   ✅ GOOD: AsNoTracking for read-only scenarios
   var blogs = await dbContext.Blogs
       .AsNoTracking()
       .ToListAsync();
   // Benefit: 30-40% faster, no tracking overhead
   // Use for: Reports, lists, searches, API GET endpoints

3. LOADING ALL COLUMNS (SELECT *):

   ❌ BAD: Fetch entire entity when only need few columns
   var blogs = await dbContext.Blogs.ToListAsync();
   var names = blogs.Select(b => b.Name).ToList();
   // Problem: Transferred Id, Name, Description, IsActive, Created, Updated
   // Network overhead: 100% more data than needed

   ✅ GOOD: Project only needed columns
   var names = await dbContext.Blogs
       .Select(b => b.Name)
       .ToListAsync();
   // Benefit: Transfers only Name column (75% less data)
   // Bonus: Automatically uses AsNoTracking (no tracking for projections)

   ✅ BETTER: Anonymous type projection for multiple columns
   var blogInfo = await dbContext.Blogs
       .Select(b => new {
           b.Name,
           PostCount = b.Posts.Count
       })
       .ToListAsync();

4. SAVECHANGES IN LOOP:

   ❌ BAD: Call SaveChanges for each entity
   for (int i = 0; i < 1000; i++) {
       dbContext.Blogs.Add(new Blog { Name = $"Blog {i}" });
       await dbContext.SaveChangesAsync();  // Database roundtrip each time!
   }
   // Problem: 1000 database calls, 1000 transactions
   // Can take 10-100 seconds for 1000 records!

   ✅ GOOD: Batch with single SaveChanges
   var blogs = new List<Blog>();
   for (int i = 0; i < 1000; i++) {
       blogs.Add(new Blog { Name = $"Blog {i}" });
   }
   dbContext.Blogs.AddRange(blogs);
   await dbContext.SaveChangesAsync();  // Single database call
   // Benefit: One transaction, completes in 1-2 seconds
   // Performance improvement: 10-50x faster!

5. FILTER IN MEMORY INSTEAD OF SQL:

   ❌ BAD: Load all, then filter in C#
   var allBlogs = await dbContext.Blogs.ToListAsync();  // Fetch all blogs
   var activeBlogs = allBlogs.Where(b => b.IsActive).ToList();  // Filter in memory
   // Problem: Transferred 1000 blogs when only 50 are active
   // Wasted: Database resources, network bandwidth, memory

   ✅ GOOD: Filter in database with WHERE clause
   var activeBlogs = await dbContext.Blogs
       .Where(b => b.IsActive)
       .ToListAsync();
   // Benefit: SQL WHERE clause, only transfers active blogs
   // Database does the work (indexed, optimized)

   KEY RULE: Call ToList/ToArray last, AFTER filtering!

6. DATABASE CALLS IN LOOPS:

   ❌ BAD: Query inside foreach
   var blogIds = new[] { 1, 2, 3, 10, 20, 50 };
   foreach (var id in blogIds) {
       var blog = await dbContext.Blogs.FindAsync(id);  // Separate query!
       Console.WriteLine(blog?.Name);
   }
   // Problem: 6 separate database queries

   ✅ GOOD: Single query with Contains (WHERE IN)
   var blogIds = new[] { 1, 2, 3, 10, 20, 50 };
   var blogs = await dbContext.Blogs
       .Where(b => blogIds.Contains(b.Id))
       .ToListAsync();
   foreach (var blog in blogs) {
       Console.WriteLine(blog.Name);
   }
   // Benefit: 1 database query with WHERE Id IN (1,2,3,10,20,50)

7. LONG-LIVED DBCONTEXT:

   ❌ BAD: DbContext lives too long
   public class BlogRepository {
       private readonly AppDbContext _context = new AppDbContext();
       
       public async Task<Blog> GetAsync(int id) {
           return await _context.Blogs.FindAsync(id);
       }
       
       public async Task UpdateAsync(Blog blog) {
           _context.Blogs.Update(blog);
           await _context.SaveChangesAsync();
       }
   }
   // Problems:
   // - Memory leaks (context tracks entities forever)
   // - Stale data (context caches old values)
   // - Thread safety issues (DbContext not thread-safe)

   ✅ GOOD: Short-lived context with 'using'
   public class BlogRepository {
       public async Task<Blog> GetAsync(int id) {
           using var context = new AppDbContext();
           return await context.Blogs.FindAsync(id);
       }  // Disposed automatically
       
       public async Task UpdateAsync(Blog blog) {
           using var context = new AppDbContext();
           context.Blogs.Update(blog);
           await context.SaveChangesAsync();
       }  // Disposed automatically
   }
   // Benefits:
   // - Fresh context for each operation
   // - Automatic cleanup (IDisposable)
   // - No memory leaks
   // - Thread-safe (each thread gets own context)

   FRAMEWORK PATTERN: Use dependency injection with scoped lifetime
   // Startup.cs
   builder.Services.AddDbContext<AppDbContext>(ServiceLifetime.Scoped);
   
   // Controller (automatically disposed at end of request)
   public class BlogsController : ControllerBase {
       private readonly AppDbContext _context;
       
       public BlogsController(AppDbContext context) {
           _context = context;  // Scoped to this HTTP request
       }
   }

8. INEFFICIENT UPDATES:

   ❌ BAD: Load entity just to update one field
   var blog = await dbContext.Blogs.FindAsync(blogId);  // Database query
   if (blog != null) {
       blog.Name = "Updated Name";
       await dbContext.SaveChangesAsync();  // UPDATE all columns
   }
   // Problem: Unnecessary SELECT query
   // Transfers entire entity just to update one field

   ✅ GOOD: Attach and mark property as modified
   var blog = new Blog { Id = blogId, Name = "Updated Name" };
   dbContext.Attach(blog);
   dbContext.Entry(blog).Property(b => b.Name).IsModified = true;
   await dbContext.SaveChangesAsync();
   // Benefit: No SELECT, updates only Name column
   // Generated SQL: UPDATE Blogs SET Name = @p0 WHERE Id = @p1

   ✅ ALTERNATIVE: Use ExecuteUpdate (EF Core 7+)
   await dbContext.Blogs
       .Where(b => b.Id == blogId)
       .ExecuteUpdateAsync(s => s.SetProperty(b => b.Name, "Updated Name"));
   // Benefit: Single SQL UPDATE, no change tracking

THE 8 GOLDEN RULES FOR EF CORE:

  1. Use Include() to avoid N+1 queries
     • Load related data in single query
     • Alternative: Use Select() for projections
  
  2. Use AsNoTracking() for read-only queries
     • 30-40% performance improvement
     • Reports, lists, searches, GET endpoints
  
  3. Use projection (Select) to load only needed columns
     • Reduces data transfer by 50-90%
     • Automatically disables tracking
     • Use anonymous types or DTOs
  
  4. Batch operations with single SaveChanges
     • AddRange instead of multiple Add + Save
     • Can be 10-50x faster
     • One transaction = atomicity
  
  5. Filter in SQL with Where(), not after ToList()
     • Database does the work
     • Indexed, optimized queries
     • Transfer only needed rows
  
  6. Batch queries with Contains() instead of loops
     • WHERE Id IN (...) is efficient
     • One query instead of N
  
  7. Keep DbContext short-lived (use 'using' statements)
     • Scoped lifetime in ASP.NET Core
     • Prevents memory leaks
     • Fresh context = fresh data
  
  8. Attach for updates without loading
     • No unnecessary SELECT queries
     • Update only changed columns
     • Or use ExecuteUpdate (EF Core 7+)

ADDITIONAL TIPS:

  • INDEX frequently queried columns
  • Use paging (Skip/Take) for large result sets
  • Consider split queries for multiple includes
  • Use compiled queries for frequently-executed queries
  • Log slow queries in production (interceptors)
  • Profile with MiniProfiler or Application Insights
  • Consider raw SQL/stored procedures for complex queries
  • Cache frequently accessed static data
  • Use DbContext pooling for high-throughput scenarios

COMMON MISTAKES SUMMARY:
  ❌ N+1 queries (not using Include)
  ❌ Tracking enabled for read-only queries
  ❌ Loading all columns instead of projecting
  ❌ SaveChanges in loops
  ❌ Filtering after ToList (in memory)
  ❌ Database calls in loops
  ❌ Long-lived DbContext instances
  ❌ Loading entity to update one field

EXAMPLE FILE: Learning/DataAccess/EntityFramework/EntityFrameworkBestPractices.cs ⭐
             (Shows all 8 patterns with working code + performance comparisons)

-------------------------------------------------------------------------------
8.7 EXCEPTION HANDLING
-------------------------------------------------------------------------------

TRY-CATCH-FINALLY:
  try {
      // Code that might throw
      var result = RiskyOperation();
  }
  catch (SpecificException ex) {
      // Handle specific exception
      _logger.LogError(ex, "Specific error");
  }
  catch (Exception ex) {
      // Handle all other exceptions
      _logger.LogError(ex, "Unexpected error");
      throw;  // Re-throw to preserve stack trace
  }
  finally {
      // Always executes (cleanup code)
      CleanupResources();
  }

EXCEPTION FILTERS (when):
  try {
      // Code
  }
  catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.NotFound) {
      // Only catch 404 errors
  }
  catch (HttpRequestException ex) when (ex.StatusCode == HttpStatusCode.Unauthorized) {
      // Only catch 401 errors
  }

CREATING CUSTOM EXCEPTIONS:
  public class OrderNotFoundException : Exception {
      public int OrderId { get; }
      
      public OrderNotFoundException(int orderId)
          : base($"Order {orderId} not found") {
          OrderId = orderId;
      }
      
      public OrderNotFoundException(int orderId, Exception innerException)
          : base($"Order {orderId} not found", innerException) {
          OrderId = orderId;
      }
  }
  
  // Usage
  if (order == null) {
      throw new OrderNotFoundException(orderId);
  }

GLOBAL EXCEPTION HANDLING (ASP.NET Core):
  // Middleware
  app.UseExceptionHandler(errorApp => {
      errorApp.Run(async context => {
          var exceptionHandler = context.Features.Get<IExceptionHandlerFeature>();
          var exception = exceptionHandler?.Error;
          
          context.Response.StatusCode = 500;
          await context.Response.WriteAsJsonAsync(new {
              error = exception?.Message
          });
      });
  });
  
  // Or custom middleware
  public class ExceptionMiddleware {
      private readonly RequestDelegate _next;
      private readonly ILogger<ExceptionMiddleware> _logger;
      
      public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger) {
          _next = next;
          _logger = logger;
      }
      
      public async Task InvokeAsync(HttpContext context) {
          try {
              await _next(context);
          }
          catch (Exception ex) {
              _logger.LogError(ex, "Unhandled exception");
              await HandleExceptionAsync(context, ex);
          }
      }
      
      private static Task HandleExceptionAsync(HttpContext context, Exception ex) {
          context.Response.StatusCode = ex switch {
              OrderNotFoundException => 404,
              UnauthorizedAccessException => 401,
              _ => 500
          };
          
          return context.Response.WriteAsJsonAsync(new {
              error = ex.Message
          });
      }
  }

BEST PRACTICES:
  • Catch specific exceptions first
  • Don't catch exceptions you can't handle
  • Use exception filters (when) for conditional catching
  • Re-throw using throw; (not throw ex;) to preserve stack trace
  • Don't use exceptions for flow control
  • Log exceptions with context
  • Create custom exceptions for domain-specific errors
  • Use global exception handlers in web apps

ASYNC EXCEPTIONS:
  try {
      await DoWorkAsync();
  }
  catch (Exception ex) {
      // Catches exceptions from async method
  }
  
  // AggregateException with Task.WhenAll
  try {
      await Task.WhenAll(task1, task2, task3);
  }
  catch (Exception ex) {
      // Only gets FIRST exception
  }
  
  // To get ALL exceptions:
  var tasks = new[] { task1, task2, task3 };
  try {
      await Task.WhenAll(tasks);
  }
  catch {
      foreach (var task in tasks) {
          if (task.IsFaulted) {
              var exception = task.Exception;  // AggregateException
          }
      }
  }

EXAMPLE FILE: Learning/PracticalPatterns/GlobalExceptionHandling.cs

-------------------------------------------------------------------------------
8.8 CONFIGURATION & OPTIONS
-------------------------------------------------------------------------------

CONFIGURATION SOURCES:
  • appsettings.json
  • User secrets (development)
  • Environment variables
  • Command-line arguments
  • Azure Key Vault, AWS Secrets Manager, etc.

READING CONFIGURATION:
  // appsettings.json
  {
    "ConnectionStrings": {
      "DefaultConnection": "Server=..."
    },
    "Logging": {
      "LogLevel": {
        "Default": "Information"
      }
    },
    "Email": {
      "SmtpServer": "smtp.example.com",
      "Port": 587,
      "Username": "user",
      "Password": "pass"
    }
  }
  
  // Direct access
  var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
  var smtpServer = builder.Configuration["Email:SmtpServer"];
  var port = builder.Configuration.GetValue<int>("Email:Port");

OPTIONS PATTERN (Preferred):
  // Options class
  public class EmailOptions {
      public const string Section = "Email";
      
      public string SmtpServer { get; set; } = "";
      public int Port { get; set; }
      public string Username { get; set; } = "";
      public string Password { get; set; } = "";
  }
  
  // Registration
  builder.Services.Configure<EmailOptions>(
      builder.Configuration.GetSection(EmailOptions.Section));
  
  // Usage via IOptions<T>
  public class EmailService {
      private readonly EmailOptions _options;
      
      public EmailService(IOptions<EmailOptions> options) {
          _options = options.Value;
      }
      
      public async Task SendAsync(string to, string subject, string body) {
          // Use _options.SmtpServer, _options.Port, etc.
      }
  }

IOPTIONSMONITOR (Reloads on change):
  public class EmailService {
      private readonly IOptionsMonitor<EmailOptions> _options;
      
      public EmailService(IOptionsMonitor<EmailOptions> options) {
          _options = options;
          _options.OnChange(newOptions => {
              // React to configuration changes
          });
      }
      
      public void Send() {
          var currentOptions = _options.CurrentValue;  // Always current
      }
  }

ENVIRONMENT-SPECIFIC CONFIGURATION:
  // appsettings.json (default)
  // appsettings.Development.json (overrides for Development)
  // appsettings.Production.json (overrides for Production)
  
  // Set environment
  // Environment variable: ASPNETCORE_ENVIRONMENT=Production
  // launchSettings.json: "ASPNETCORE_ENVIRONMENT": "Development"

USER SECRETS (Development only):
  // Initialize user secrets
  dotnet user-secrets init
  
  // Set secret
  dotnet user-secrets set "Email:Password" "secret123"
  
  // Access like normal configuration
  var password = builder.Configuration["Email:Password"];

EXAMPLE FILE: Learning/Configuration/ConfigurationPatterns.cs

-------------------------------------------------------------------------------
8.9 LOGGING
-------------------------------------------------------------------------------

BUILT-IN LOGGING:
  .NET includes Microsoft.Extensions.Logging. No need for third-party logger
  in most cases (though Serilog, NLog are popular alternatives).

LOG LEVELS:
  • Trace (0): Most detailed
  • Debug (1): Development info
  • Information (2): General flow
  • Warning (3): Unexpected but not errors
  • Error (4): Errors and exceptions
  • Critical (5): Critical failures
  • None (6): Disable logging

USAGE:
  public class OrderService {
      private readonly ILogger<OrderService> _logger;
      
      public OrderService(ILogger<OrderService> logger) {
          _logger = logger;
      }
      
      public async Task<Order> CreateOrderAsync(CreateOrderRequest request) {
          _logger.LogInformation("Creating order for customer {CustomerId}", request.CustomerId);
          
          try {
              var order = await _repository.CreateAsync(request);
              _logger.LogInformation("Order {OrderId} created successfully", order.Id);
              return order;
          }
          catch (Exception ex) {
              _logger.LogError(ex, "Failed to create order for customer {CustomerId}", request.CustomerId);
              throw;
          }
      }
  }

STRUCTURED LOGGING:
  // Good: Structured (can query by CustomerId)
  _logger.LogInformation("Creating order for customer {CustomerId}", request.CustomerId);
  
  // Bad: String interpolation (just a string)
  _logger.LogInformation($"Creating order for customer {request.CustomerId}");

CONFIGURATION:
  // appsettings.json
  {
    "Logging": {
      "LogLevel": {
        "Default": "Information",
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Information"
      }
    }
  }

LOG PROVIDERS:
  // Add providers
  builder.Logging.ClearProviders();
  builder.Logging.AddConsole();
  builder.Logging.AddDebug();
  builder.Logging.AddEventSourceLogger();
  
  // Third-party: Serilog
  builder.Host.UseSerilog((context, config) => {
      config.ReadFrom.Configuration(context.Configuration);
  });

SCOPES:
  using (_logger.BeginScope("OrderId: {OrderId}", orderId)) {
      _logger.LogInformation("Processing order");
      _logger.LogInformation("Order validated");
      // Both log entries include OrderId in scope
  }

BEST PRACTICES:
  • Use structured logging (templates with placeholders)
  • Don't log sensitive data (passwords, credit cards)
  • Appropriate log levels
  • Include correlation IDs for distributed systems
  • Use scopes for related log entries
  • Consider performance (logging can be expensive)
  • Async logging for high-volume applications

EXAMPLE FILE: Learning/Logging/LoggingBestPractices.cs

===============================================================================
PART 9: PRACTICAL EXAMPLES & BEST PRACTICES
===============================================================================

Real-world scenarios and guidelines for professional development.

-------------------------------------------------------------------------------
9.1 REPOSITORY PATTERN
-------------------------------------------------------------------------------

PURPOSE:
  Mediates between domain and data mapping layers. Provides collection-like
  interface for accessing domain objects.

BENEFITS:
  • Decouples business logic from data access
  • Centralizes data access logic
  • Easier to test (mock repository)
  • Easier to switch data sources

IMPLEMENTATION:
  // Repository interface
  public interface IOrderRepository {
      Task<Order?> GetByIdAsync(int id);
      Task<IEnumerable<Order>> GetAllAsync();
      Task<IEnumerable<Order>> GetByCustomerIdAsync(int customerId);
      Task<Order> AddAsync(Order order);
      Task UpdateAsync(Order order);
      Task DeleteAsync(int id);
  }
  
  // Implementation with EF Core
  public class OrderRepository : IOrderRepository {
      private readonly AppDbContext _context;
      
      public OrderRepository(AppDbContext context) {
          _context = context;
      }
      
      public async Task<Order?> GetByIdAsync(int id) {
          return await _context.Orders
              .Include(o => o.Items)
              .FirstOrDefaultAsync(o => o.Id == id);
      }
      
      public async Task<IEnumerable<Order>> GetAllAsync() {
          return await _context.Orders
              .AsNoTracking()
              .ToListAsync();
      }
      
      public async Task<IEnumerable<Order>> GetByCustomerIdAsync(int customerId) {
          return await _context.Orders
              .Where(o => o.CustomerId == customerId)
              .AsNoTracking()
              .ToListAsync();
      }
      
      public async Task<Order> AddAsync(Order order) {
          _context.Orders.Add(order);
          await _context.SaveChangesAsync();
          return order;
      }
      
      public async Task UpdateAsync(Order order) {
          _context.Entry(order).State = EntityState.Modified;
          await _context.SaveChangesAsync();
      }
      
      public async Task DeleteAsync(int id) {
          var order = await _context.Orders.FindAsync(id);
          if (order != null) {
              _context.Orders.Remove(order);
              await _context.SaveChangesAsync();
          }
      }
  }
  
  // Registration
  builder.Services.AddScoped<IOrderRepository, OrderRepository>();
  
  // Usage in service
  public class OrderService {
      private readonly IOrderRepository _repository;
      
      public OrderService(IOrderRepository repository) {
          _repository = repository;
      }
      
      public async Task<Order> GetOrderAsync(int id) {
          var order = await _repository.GetByIdAsync(id);
          if (order == null) throw new OrderNotFoundException(id);
          return order;
      }
  }

GENERIC REPOSITORY (Optional):
  public interface IRepository<T> where T : class {
      Task<T?> GetByIdAsync(int id);
      Task<IEnumerable<T>> GetAllAsync();
      Task<T> AddAsync(T entity);
      Task UpdateAsync(T entity);
      Task DeleteAsync(int id);
  }
  
  public class Repository<T> : IRepository<T> where T : class {
      protected readonly AppDbContext _context;
      protected readonly DbSet<T> _dbSet;
      
      public Repository(AppDbContext context) {
          _context = context;
          _dbSet = context.Set<T>();
      }
      
      public virtual async Task<T?> GetByIdAsync(int id) {
          return await _dbSet.FindAsync(id);
      }
      
      // Implement other methods...
  }

UNIT OF WORK (Optional - complements Repository):
  public interface IUnitOfWork {
      IOrderRepository Orders { get; }
      ICustomerRepository Customers { get; }
      Task<int> SaveChangesAsync();
  }
  
  public class UnitOfWork : IUnitOfWork {
      private readonly AppDbContext _context;
      
      public UnitOfWork(AppDbContext context) {
          _context = context;
          Orders = new OrderRepository(context);
          Customers = new CustomerRepository(context);
      }
      
      public IOrderRepository Orders { get; }
      public ICustomerRepository Customers { get; }
      
      public async Task<int> SaveChangesAsync() {
          return await _context.SaveChangesAsync();
      }
  }

EXAMPLE FILE: PracticalExamples/RepositoryPattern.cs

-------------------------------------------------------------------------------
9.2 API BEST PRACTICES
-------------------------------------------------------------------------------

RESTFUL CONVENTIONS:
  • GET: Retrieve resources (idempotent)
  • POST: Create resources
  • PUT: Update entire resource (idempotent)
  • PATCH: Partial update
  • DELETE: Delete resources (idempotent)

HTTP STATUS CODES:
  • 200 OK: Successful GET, PUT, PATCH
  • 201 Created: Successful POST
  • 204 No Content: Successful DELETE
  • 400 Bad Request: Invalid request
  • 401 Unauthorized: Missing/invalid authentication
  • 403 Forbidden: Authenticated but not authorized
  • 404 Not Found: Resource doesn't exist
  • 409 Conflict: Conflict with current state
  • 500 Internal Server Error: Server error

EXAMPLE API CONTROLLER:
  [ApiController]
  [Route("api/[controller]")]
  public class OrdersController : ControllerBase {
      private readonly IOrderService _orderService;
      private readonly ILogger<OrdersController> _logger;
      
      public OrdersController(IOrderService orderService, ILogger<OrdersController> logger) {
          _orderService = orderService;
          _logger = logger;
      }
      
      // GET api/orders
      [HttpGet]
      [ProducesResponseType(typeof(IEnumerable<OrderDto>), 200)]
      public async Task<ActionResult<IEnumerable<OrderDto>>> GetAll() {
          var orders = await _orderService.GetAllOrdersAsync();
          return Ok(orders);
      }
      
      // GET api/orders/5
      [HttpGet("{id}")]
      [ProducesResponseType(typeof(OrderDto), 200)]
      [ProducesResponseType(404)]
      public async Task<ActionResult<OrderDto>> GetById(int id) {
          try {
              var order = await _orderService.GetOrderAsync(id);
              return Ok(order);
          }
          catch (OrderNotFoundException) {
              return NotFound();
          }
      }
      
      // POST api/orders
      [HttpPost]
      [ProducesResponseType(typeof(OrderDto), 201)]
      [ProducesResponseType(400)]
      public async Task<ActionResult<OrderDto>> Create(CreateOrderRequest request) {
          if (!ModelState.IsValid) {
              return BadRequest(ModelState);
          }
          
          var order = await _orderService.CreateOrderAsync(request);
          return CreatedAtAction(nameof(GetById), new { id = order.Id }, order);
      }
      
      // PUT api/orders/5
      [HttpPut("{id}")]
      [ProducesResponseType(200)]
      [ProducesResponseType(404)]
      public async Task<IActionResult> Update(int id, UpdateOrderRequest request) {
          try {
              await _orderService.UpdateOrderAsync(id, request);
              return Ok();
          }
          catch (OrderNotFoundException) {
              return NotFound();
          }
      }
      
      // DELETE api/orders/5
      [HttpDelete("{id}")]
      [ProducesResponseType(204)]
      [ProducesResponseType(404)]
      public async Task<IActionResult> Delete(int id) {
          try {
              await _order Service.DeleteOrderAsync(id);
              return NoContent();
          }
          catch (OrderNotFoundException) {
              return NotFound();
          }
      }
  }

VALIDATION:
  public class CreateOrderRequest {
      [Required]
      [Range(1, int.MaxValue)]
      public int CustomerId { get; set; }
      
      [Required]
      [MinLength(1)]
      public List<OrderItemRequest> Items { get; set; } = new();
  }
  
  public class OrderItemRequest {
      [Required]
      [Range(1, int.MaxValue)]
      public int ProductId { get; set; }
      
      [Required]
      [Range(1, 1000)]
      public int Quantity { get; set; }
  }

VERSIONING:
  // URL versioning
  [Route("api/v1/[controller]")]
  
  // Header versioning
  [ApiVersion("1.0")]
  [Route("api/[controller]")]
  
  // Query string versioning
  // api/orders?api-version=1.0

PAGINATION:
  [HttpGet]
  public async Task<ActionResult<PagedResult<OrderDto>>> GetAll(
      [FromQuery] int page = 1,
      [FromQuery] int pageSize = 10) {
      
      var result = await _orderService.GetOrdersAsync(page, pageSize);
      return Ok(result);
  }
  
  public class PagedResult<T> {
      public IEnumerable<T> Items { get; set; } = new List<T>();
      public int TotalCount { get; set; }
      public int Page { get; set; }
      public int PageSize { get; set; }
      public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
      public bool HasPrevious => Page > 1;
      public bool HasNext => Page < TotalPages;
  }

BEST PRACTICES:
  • Use DTOs (don't expose domain models)
  • Validate input
  • Use appropriate HTTP status codes
  • Version your API
  • Implement paging for large collections
  • Use async/await
  • Document with Swagger/OpenAPI
  • Implement proper error handling
  • Use HTTPS always
  • Rate limiting for public APIs

EXAMPLE FILE: PracticalExamples/APIBestPractices.cs

-------------------------------------------------------------------------------
9.3 TESTING BEST PRACTICES
-------------------------------------------------------------------------------

TEST TYPES:
  • Unit Tests: Test individual methods/classes in isolation
  • Integration Tests: Test multiple components together
  • End-to-End Tests: Test entire application flow

UNIT TEST EXAMPLE (xUnit + Moq):
  public class OrderServiceTests {
      private readonly Mock<IOrderRepository> _repositoryMock;
      private readonly Mock<IEmailService> _emailMock;
      private readonly OrderService _sut; // System Under Test
      
      public OrderServiceTests() {
          _repositoryMock = new Mock<IOrderRepository>();
          _emailMock = new Mock<IEmailService>();
          _sut = new OrderService(_repositoryMock.Object, _emailMock.Object);
      }
      
      [Fact]
      public async Task CreateOrder_ValidRequest_ReturnsOrder() {
          // Arrange
          var request = new CreateOrderRequest {
              CustomerId = 1,
              Items = new List<OrderItemRequest> {
                  new() { ProductId = 1, Quantity = 2 }
              }
          };
          
          _repositoryMock
              .Setup(r => r.AddAsync(It.IsAny<Order>()))
              .ReturnsAsync((Order o) => { o.Id = 1; return o; });
          
          // Act
          var result = await _sut.CreateOrderAsync(request);
          
          // Assert
          Assert.NotNull(result);
          Assert.Equal(1, result.Id);
          _repositoryMock.Verify(r => r.AddAsync(It.IsAny<Order>()), Times.Once);
          _emailMock.Verify(e => e.SendAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()), Times.Once);
      }
      
      [Fact]
      public async Task GetOrder_NonExistentId_ThrowsOrderNotFoundException() {
          // Arrange
          _repositoryMock
              .Setup(r => r.GetByIdAsync(It.IsAny<int>()))
              .ReturnsAsync((Order?)null);
          
          // Act & Assert
          await Assert.ThrowsAsync<OrderNotFoundException>(() => _sut.GetOrderAsync(999));
      }
      
      [Theory]
      [InlineData(0)]
      [InlineData(-1)]
      public async Task CreateOrder_InvalidCustomerId_ThrowsArgumentException(int customerId) {
          // Arrange
          var request = new CreateOrderRequest { CustomerId = customerId };
          
          // Act & Assert
          await Assert.ThrowsAsync<ArgumentException>(() => _sut.CreateOrderAsync(request));
      }
  }

INTEGRATION TEST EXAMPLE:
  public class OrdersIntegrationTests : IClassFixture<WebApplicationFactory<Program>> {
      private readonly HttpClient _client;
      
      public OrdersIntegrationTests(WebApplicationFactory<Program> factory) {
          _client = factory.CreateClient();
      }
      
      [Fact]
      public async Task GetOrders_ReturnsOkWithOrders() {
          // Act
          var response = await _client.GetAsync("/api/orders");
          
          // Assert
          response.EnsureSuccessStatusCode();
          var content = await response.Content.ReadAsStringAsync();
          var orders = JsonSerializer.Deserialize<List<OrderDto>>(content);
          Assert.NotNull(orders);
      }
      
      [Fact]
      public async Task CreateOrder_ValidRequest_Returns201() {
          // Arrange
          var request = new CreateOrderRequest {
              CustomerId = 1,
              Items = new List<OrderItemRequest> {
                  new() { ProductId = 1, Quantity = 2 }
              }
          };
          
          var json = JsonSerializer.Serialize(request);
          var content = new StringContent(json, Encoding.UTF8, "application/json");
          
         // Act
          var response = await _client.PostAsync("/api/orders", content);
          
          // Assert
          Assert.Equal(HttpStatusCode.Created, response.StatusCode);
      }
  }

AAA PATTERN:
  // Arrange: Set up test data and dependencies
  // Act: Execute the method under test
  // Assert: Verify the results

NAMING CONVENTIONS:
  // MethodName_Scenario_ExpectedBehavior
  GetOrder_ExistingId_ReturnsOrder
  GetOrder_NonExistentId_ThrowsOrderNotFoundException
  CreateOrder_ValidRequest_SavesAndReturnsOrder

WHAT TO TEST:
  ✅ Public methods
  ✅ Business logic
  ✅ Edge cases
  ✅ Error conditions
  ✅ Integration points
  
  ❌ Private methods (test through public methods)
  ❌ Framework code
  ❌ Trivial properties
  ❌ Third-party libraries

BEST PRACTICES:
  • One assertion per test (generally)
  • Tests should be independent
  • Tests should be fast
  • Use descriptive names
  • Arrange-Act-Assert pattern
  • Mock external dependencies
  • Test edge cases and error conditions
  • Use Test Data Builders for complex objects
  • Aim for high code coverage (80%+) but don't obsess

MOCKING WITH MOQ:
  // Setup method return value
  mock.Setup(m => m.GetById(1)).Returns(order);
  mock.Setup(m => m.GetByIdAsync(1)).ReturnsAsync(order);
  
  // Setup with any argument
  mock.Setup(m => m.GetById(It.IsAny<int>())).Returns(order);
  
  // Setup with condition
  mock.Setup(m => m.GetById(It.Is<int>(id => id > 0))).Returns(order);
  
  // Verify method was called
  mock.Verify(m => m.GetById(1), Times.Once);
  mock.Verify(m => m.GetById(It.IsAny<int>()), Times.AtLeastOnce);
  
  // Setup to throw exception
  mock.Setup(m => m.GetById(999)).Throws<OrderNotFoundException>();

EXAMPLE FILE: PracticalExamples/TestingBestPractices.cs

-------------------------------------------------------------------------------
9.3.1 TESTING FRAMEWORKS - xUnit vs NUnit vs MSTest
-------------------------------------------------------------------------------

XUNIT (Recommended - Modern approach):
  Features:
  • No [SetUp]/[TearDown] (use constructor/IDisposable instead)
  • Parallel test execution by default
  • Theory tests with inline data
  • Modern, clean API
  • Used by .NET Core team
  
  Installation:
  dotnet add package xunit
  dotnet add package xunit.runner.visualstudio
  dotnet add package Microsoft.NET.Test.Sdk
  
  Basic Test:
  public class CalculatorTests {
      [Fact]  // Single test
      public void Add_TwoNumbers_ReturnsSum() {
          // Arrange
          var calculator = new Calculator();
          
          // Act
          var result = calculator.Add(2, 3);
          
          // Assert
          Assert.Equal(5, result);
      }
      
      [Theory]  // Parameterized test
      [InlineData(2, 3, 5)]
      [InlineData(0, 0, 0)]
      [InlineData(-1, 1, 0)]
      [InlineData(int.MaxValue, 1, int.MinValue)]  // Overflow test
      public void Add_VariousInputs_ReturnsExpectedSum(int a, int b, int expected) {
          var calculator = new Calculator();
          var result = calculator.Add(a, b);
          Assert.Equal(expected, result);
      }
      
      [Theory]
      [MemberData(nameof(GetTestData))]
      public void Add_ComplexTestData_ReturnsExpectedSum(int a, int b, int expected) {
          var calculator = new Calculator();
          var result = calculator.Add(a, b);
          Assert.Equal(expected, result);
      }
      
      public static IEnumerable<object[]> GetTestData() {
          yield return new object[] { 1, 2, 3 };
          yield return new object[] { 5, 5, 10 };
          yield return new object[] { -1, -1, -2 };
      }
  }
  
  Setup/Teardown:
  public class DatabaseTests : IDisposable {
      private readonly AppDbContext _context;
      
      public DatabaseTests() {
          // Constructor = Setup
          _context = CreateInMemoryDatabase();
      }
      
      [Fact]
      public void Test_Something() {
          // Test using _context
      }
      
      public void Dispose() {
          // Dispose = Teardown
          _context.Dispose();
      }
  }
  
  Shared Context (IClassFixture):
  public class DatabaseFixture : IDisposable {
      public AppDbContext DbContext { get; private set; }
      
      public DatabaseFixture() {
          DbContext = CreateInMemoryDatabase();
      }
      
      public void Dispose() {
          DbContext.Dispose();
      }
  }
  
  public class OrderTests : IClassFixture<DatabaseFixture> {
      private readonly DatabaseFixture _fixture;
      
      public OrderTests(DatabaseFixture fixture) {
          _fixture = fixture;
      }
      
      [Fact]
      public async Task Test_WithSharedContext() {
          // Use _fixture.DbContext
      }
  }

NUNIT (Traditional, Feature-rich):
  Features:
  • Rich assertion library
  • Extensive attributes
  • [SetUp]/[TearDown] support
  • Test fixtures
  • Wide adoption, mature
  
  Installation:
  dotnet add package NUnit
  dotnet add package NUnit3TestAdapter
  dotnet add package Microsoft.NET.Test.Sdk
  
  Basic Test:
  [TestFixture]
  public class CalculatorTests {
      private Calculator _calculator;
      
      [SetUp]
      public void Setup() {
          _calculator = new Calculator();
      }
      
      [Test]
      public void Add_TwoNumbers_ReturnsSum() {
          var result = _calculator.Add(2, 3);
          Assert.That(result, Is.EqualTo(5));
      }
      
      [TestCase(2, 3, 5)]
      [TestCase(0, 0, 0)]
      [TestCase(-1, 1, 0)]
      public void Add_VariousInputs_ReturnsExpectedSum(int a, int b, int expected) {
          var result = _calculator.Add(a, b);
          Assert.That(result, Is.EqualTo(expected));
      }
      
      [Test]
      [Category("SlowTests")]
      [Timeout(5000)]
      public void LongRunningOperation_CompletesInTime() {
          // Test that must complete within 5 seconds
      }
      
      [TearDown]
      public void Teardown() {
          _calculator = null;
      }
  }

MSTEST (Built-in with Visual Studio):
  Features:
  • Integrated with Visual Studio
  • Microsoft supported
  • DataRow for parameterized tests
  • Simple and straightforward
  
  Installation:
  dotnet add package MSTest.TestFramework
  dotnet add package MSTest.TestAdapter
  dotnet add package Microsoft.NET.Test.Sdk
  
  Basic Test:
  [TestClass]
  public class CalculatorTests {
      private Calculator _calculator;
      
      [TestInitialize]
      public void Initialize() {
          _calculator = new Calculator();
      }
      
      [TestMethod]
      public void Add_TwoNumbers_ReturnsSum() {
          var result = _calculator.Add(2, 3);
          Assert.AreEqual(5, result);
      }
      
      [DataTestMethod]
      [DataRow(2, 3, 5)]
      [DataRow(0, 0, 0)]
      [DataRow(-1, 1, 0)]
      public void Add_VariousInputs_ReturnsExpectedSum(int a, int b, int expected) {
          var result = _calculator.Add(a, b);
          Assert.AreEqual(expected, result);
      }
      
      [TestCleanup]
      public void Cleanup() {
          _calculator = null;
      }
  }

COMPARISON:

  FEATURE               xUnit          NUnit          MSTest
  ─────────────────────────────────────────────────────────────
  Modern design         ✅ Yes         ❌ No          ❌ No
  Parallel execution    ✅ Default     ⚠️ Optional    ⚠️ Optional
  Setup/Teardown        Constructor    [SetUp]        [TestInitialize]
  Parameterized tests   [Theory]       [TestCase]     [DataTestMethod]
  Assertion style       Assert.Equal   Assert.That    Assert.AreEqual
  Community choice      ✅ Popular     ✅ Popular     ⚠️ Less popular
  VS Integration        ✅ Good        ✅ Excellent   ✅ Excellent

RECOMMENDATION:
  • xUnit: New projects, modern approach
  • NUnit: Existing projects, rich features needed
  • MSTest: Visual Studio-centric projects

EXAMPLE FILE: Learning/Testing/TestingFrameworksComparison.cs

-------------------------------------------------------------------------------
9.3.2 MOCKING IN DEPTH
-------------------------------------------------------------------------------

WHY MOCK?
  • Isolate unit under test
  • Control dependencies behavior
  • Verify interactions
  • Faster tests (no real database/network)
  • Test error scenarios

MOQ - MOST POPULAR .NET MOCKING LIBRARY:
  Installation:
  dotnet add package Moq
  
  Basic Setup:
  var mock = new Mock<IOrderRepository>();
  var repository = mock.Object;  // Get mocked instance

SETUP RETURN VALUES:
  // Return specific value
  mock.Setup(r => r.GetByIdAsync(1))
      .ReturnsAsync(new Order { Id = 1, Total = 100 });
  
  // Return based on input
  mock.Setup(r => r.GetByIdAsync(It.IsAny<int>()))
      .ReturnsAsync((int id) => new Order { Id = id });
  
  // Return different values on successive calls
  mock.SetupSequence(r => r.GetNextAsync())
      .ReturnsAsync(order1)
      .ReturnsAsync(order2)
      .ReturnsAsync((Order)null);  // Third call returns null

ARGUMENT MATCHERS:
  // Any value
  mock.Setup(r => r.GetByIdAsync(It.IsAny<int>()))
      .ReturnsAsync(order);
  
  // Specific condition
  mock.Setup(r => r.GetByIdAsync(It.Is<int>(id => id > 0)))
      .ReturnsAsync(order);
  
  // Range
  mock.Setup(r => r.GetByIdAsync(It.IsInRange(1, 100, Range.Inclusive)))
      .ReturnsAsync(order);
  
  // Regular expression
  mock.Setup(r => r.FindByName(It.IsRegex("[A-Z]{3}")))
      .ReturnsAsync(customers);
  
  // Complex object matching
  mock.Setup(r => r.AddAsync(It.Is<Order>(o => o.Total > 100 && o.CustomerId > 0)))
      .ReturnsAsync((Order o) => o);

THROWING EXCEPTIONS:
  // Throw exception
  mock.Setup(r => r.GetByIdAsync(999))
      .ThrowsAsync(new OrderNotFoundException(999));
  
  // Throw based on condition
  mock.Setup(r => r.AddAsync(It.Is<Order>(o => o.Total < 0)))
      .ThrowsAsync(new ArgumentException("Total cannot be negative"));

CALLBACKS:
  // Execute code when method called
  var capturedOrder = null as Order;
  mock.Setup(r => r.AddAsync(It.IsAny<Order>()))
      .Callback<Order>(o => capturedOrder = o)
      .ReturnsAsync((Order o) => o);
  
  // Can verify captured value later
  Assert.Equal(expectedId, capturedOrder.Id);

VERIFICATION:
  // Verify method was called
  mock.Verify(r => r.GetByIdAsync(1), Times.Once);
  mock.Verify(r => r.GetByIdAsync(It.IsAny<int>()), Times.AtLeastOnce);
  mock.Verify(r => r.GetByIdAsync(It.IsAny<int>()), Times.Between(1, 5, Range.Inclusive));
  
  // Verify method was never called
  mock.Verify(r => r.DeleteAsync(It.IsAny<int>()), Times.Never);
  
  // Verify all setups were called
  mock.VerifyAll();
  
  // Verify no other calls were made
  mock.VerifyNoOtherCalls();

PROPERTIES:
  // Setup property
  mock.Setup(r => r.ConnectionString).Returns("Server=test");
  
  // Auto-implement properties (track get/set)
  mock.SetupProperty(r => r.ConnectionString);
  mock.Object.ConnectionString = "New Value";
  Assert.Equal("New Value", mock.Object.ConnectionString);
  
  // Auto-implement all properties
  mock.SetupAllProperties();

EVENTS:
  // Raise event
  mock.Raise(r => r.OrderCreated += null, new OrderEventArgs(order));
  
  // In test
  bool eventRaised = false;
  mock.Object.OrderCreated += (s, e) => eventRaised = true;
  mock.Raise(r => r.OrderCreated += null, new OrderEventArgs(order));
  Assert.True(eventRaised);

PARTIAL MOCKS (CallBase):
  // Call real implementation by default, mock specific methods
  var mock = new Mock<ProductService> { CallBase = true };
  mock.Setup(s => s.GetPriceAsync(It.IsAny<int>()))
      .ReturnsAsync(99.99m);  // Override this method
  // Other methods call real implementation

STRICT VS LOOSE MOCKS:
  // Loose (default): Returns default values for unmocked methods
  var mock = new Mock<IOrderRepository>();
  var order = await mock.Object.GetByIdAsync(1);  // Returns null
  
  // Strict: Throws exception for unmocked methods
  var strictMock = new Mock<IOrderRepository>(MockBehavior.Strict);
  var order = await strictMock.Object.GetByIdAsync(1);  // Throws exception!

LINQ TO MOCKS:
  // Create mock using LINQ-style syntax
  var mock = Mock.Of<IOrderRepository>(r =>
      r.GetByIdAsync(1) == Task.FromResult(order) &&
      r.GetAllAsync() == Task.FromResult<IEnumerable<Order>>(orders));

ADVANCED SCENARIOS:
  // Mock protected members (requires Moq.Protected)
  mock.Protected()
      .Setup<Task<Order>>("GetOrderInternalAsync", ItExpr.IsAny<int>())
      .ReturnsAsync(order);
  
  // Mock sequences
  mock.SetupSequence(r => r.GetStatusAsync())
      .ReturnsAsync("Pending")
      .ReturnsAsync("Processing")
      .ReturnsAsync("Completed");

TESTING WITH MOCKS - COMPLETE EXAMPLE:
  public class OrderServiceTests {
      private readonly Mock<IOrderRepository> _repositoryMock;
      private readonly Mock<ICustomerRepository> _customerMock;
      private readonly Mock<IEmailService> _emailMock;
      private readonly Mock<ILogger<OrderService>> _loggerMock;
      private readonly OrderService _sut;
      
      public OrderServiceTests() {
          _repositoryMock = new Mock<IOrderRepository>();
          _customerMock = new Mock<ICustomerRepository>();
          _emailMock = new Mock<IEmailService>();
          _loggerMock = new Mock<ILogger<OrderService>>();
          
          _sut = new OrderService(
              _repositoryMock.Object,
              _customerMock.Object,
              _emailMock.Object,
              _loggerMock.Object);
      }
      
      [Fact]
      public async Task CreateOrder_ValidRequest_CreatesOrderAndSendsEmail() {
          // Arrange
          var customer = new Customer { Id = 1, Email = "test@example.com" };
          var request = new CreateOrderRequest { CustomerId = 1, Items = [...] };
          var capturedOrder = null as Order;
          
          _customerMock
              .Setup(c => c.GetByIdAsync(1))
              .ReturnsAsync(customer);
          
          _repositoryMock
              .Setup(r => r.AddAsync(It.IsAny<Order>()))
              .Callback<Order>(o => capturedOrder = o)
              .ReturnsAsync((Order o) => { o.Id = 100; return o; });
          
          _emailMock
              .Setup(e => e.SendAsync(customer.Email, It.IsAny<string>(), It.IsAny<string>()))
              .ReturnsAsync(true);
          
          // Act
          var result = await _sut.CreateOrderAsync(request);
          
          // Assert
          Assert.NotNull(result);
          Assert.Equal(100, result.Id);
          Assert.Equal(1, result.CustomerId);
          
          _customerMock.Verify(c => c.GetByIdAsync(1), Times.Once);
          _repositoryMock.Verify(r => r.AddAsync(It.IsAny<Order>()), Times.Once);
          _emailMock.Verify(e => 
              e.SendAsync(customer.Email, "Order Confirmation", It.IsAny<string>()), 
              Times.Once);
          
          Assert.NotNull(capturedOrder);
          Assert.Equal(request.CustomerId, capturedOrder.CustomerId);
      }
      
      [Fact]
      public async Task CreateOrder_CustomerNotFound_ThrowsException() {
          // Arrange
          var request = new CreateOrderRequest { CustomerId = 999 };
          
          _customerMock
              .Setup(c => c.GetByIdAsync(999))
              .ReturnsAsync((Customer)null);
          
          // Act & Assert
          await Assert.ThrowsAsync<CustomerNotFoundException>(
              () => _sut.CreateOrderAsync(request));
          
          // Verify repository not called
          _repositoryMock.Verify(r => r.AddAsync(It.IsAny<Order>()), Times.Never);
          _emailMock.Verify(e => e.SendAsync(It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>()), Times.Never);
      }
  }

MOCK ALTERNATIVES:
  • NSubstitute: More fluent syntax
  • FakeItEasy: Less ceremony
  • Manual fakes: Full control, more work

WHEN NOT TO MOCK:
  ❌ Value objects (simple data classes)
  ❌ Pure functions
  ❌ Framework classes (HttpContext - use TestServer instead)
  ❌ Database (use in-memory database instead)

BEST PRACTICES:
  • Mock interfaces, not concrete classes
  • Don't over-verify (test behavior, not implementation)
  • One mock setup per test (focused tests)
  • Use strict mocks for critical paths
  • Verify only important interactions
  • Keep mocks simple
  • Consider using test doubles (fakes) for complex scenarios

EXAMPLE FILE: Learning/Testing/MockingInDepth.cs

-------------------------------------------------------------------------------
9.3.3 TEST DATA BUILDERS
-------------------------------------------------------------------------------

PROBLEM:
  Creating test objects with many properties is tedious and repetitive.
  Tests become brittle when object structure changes.

SOLUTION:
  Test Data Builders - fluent API for creating test objects.

WITHOUT BUILDER (Bad):
  [Fact]
  public void Test1() {
      var customer = new Customer {
          Id = 1,
          Name = "John Doe",
          Email = "john@example.com",
          Phone = "123-456-7890",
          Address = new Address {
              Street = "123 Main St",
              City = "Springfield",
              State = "IL",
              ZipCode = "62701"
          },
          Orders = new List<Order>(),
          CreatedDate = DateTime.UtcNow,
          IsActive = true,
          CreditLimit = 5000
      };
      // Test...
  }
  
  [Fact]
  public void Test2() {
      // Same setup code repeated!
      var customer = new Customer { ...};
  }

WITH BUILDER (Good):
  public class CustomerBuilder {
      private int _id = 1;
      private string _name = "John Doe";
      private string _email = "john@example.com";
      private string _phone = "123-456-7890";
      private Address _address = new AddressBuilder().Build();
      private List<Order> _orders = new();
      private DateTime _createdDate = DateTime.UtcNow;
      private bool _isActive = true;
      private decimal _creditLimit = 5000;
      
      public CustomerBuilder WithId(int id) {
          _id = id;
          return this;
      }
      
      public CustomerBuilder WithName(string name) {
          _name = name;
          return this;
      }
      
      public CustomerBuilder WithEmail(string email) {
          _email = email;
          return this;
      }
      
      public CustomerBuilder WithAddress(Address address) {
          _address = address;
          return this;
      }
      
      public CustomerBuilder WithOrders(params Order[] orders) {
          _orders = orders.ToList();
          return this;
      }
      
      public CustomerBuilder Inactive() {
          _isActive = false;
          return this;
      }
      
      public CustomerBuilder WithCreditLimit(decimal limit) {
          _creditLimit = limit;
          return this;
      }
      
      public Customer Build() {
          return new Customer {
              Id = _id,
              Name = _name,
              Email = _email,
              Phone = _phone,
              Address = _address,
              Orders = _orders,
              CreatedDate = _createdDate,
              IsActive = _isActive,
              CreditLimit = _creditLimit
          };
      }
      
      // Convenience method for quick creation
      public static implicit operator Customer(CustomerBuilder builder) =>  builder.Build();
  }

USAGE:
  [Fact]
  public void CalculateDiscount_ActiveCustomerWithHighCredit_AppliesPremiumDiscount() {
      // Arrange - clear and concise
      var customer = new CustomerBuilder()
          .WithCreditLimit(10000)
          .Build();
      
      // Act
      var discount = _service.CalculateDiscount(customer);
      
      // Assert
      Assert.Equal(0.15m, discount);
  }
  
  [Fact]
  public void SendEmail_InactiveCustomer_ThrowsException() {
      // Arrange
      var customer = new CustomerBuilder()
          .Inactive()
          .Build();
      
      // Act & Assert
      Assert.Throws<InvalidOperationException>(() => _service.SendEmail(customer));
  }
  
  [Fact]
  public void GetTotalOrders_CustomerWithThreeOrders_ReturnsThree() {
      // Arrange
      var orders = new[] {
          new OrderBuilder().Build(),
          new OrderBuilder().WithTotal(200).Build(),
          new OrderBuilder().WithTotal(300).Build()
      };
      
      var customer = new CustomerBuilder()
          .WithOrders(orders)
          .Build();
      
      // Act
      var total = customer.Orders.Count;
      
      // Assert
      Assert.Equal(3, total);
  }

ADVANCED PATTERNS:

1. OBJECT MOTHER (Named Scenarios):
   public static class CustomerMother {
       public static Customer CreateDefault() =>
           new CustomerBuilder().Build();
       
       public static Customer CreatePremium() =>
           new CustomerBuilder()
               .WithCreditLimit(50000)
               .Build();
       
       public static Customer CreateInactive() =>
           new CustomerBuilder()
               .Inactive()
               .Build();
       
       public static Customer CreateWithManyOrders() =>
           new CustomerBuilder()
               .WithOrders(
                   OrderMother.CreateDefault(),
                   OrderMother.CreateDefault(),
                   OrderMother.CreateDefault())
               .Build();
   }
   
   // Usage
   var customer = CustomerMother.CreatePremium();

2. AUTO-INCREMENT IDS:
   public class CustomerBuilder {
       private static int _nextId = 1;
       private int _id = _nextId++;
       // ... rest of builder
   }
   
   // Each build gets unique ID automatically
   var customer1 = new CustomerBuilder().Build();  // Id = 1
   var customer2 = new CustomerBuilder().Build();  // Id = 2

3. RANDOM DATA:
   public class CustomerBuilder {
       private static readonly Random _random = new();
       private string _name = $"Customer{_random.Next(1000, 9999)}";
       private string _email = $"customer{_random.Next(1000, 9999)}@example.com";
       // ...
   }

4. COLLECTION BUILDERS:
   public class CustomerCollectionBuilder {
       private int _count = 1;
       private Action<CustomerBuilder, int> _configure = (b, i) => { };
       
       public CustomerCollectionBuilder WithCount(int count) {
           _count = count;
           return this;
       }
       
       public CustomerCollectionBuilder Configure(Action<CustomerBuilder, int> configure) {
           _configure = configure;
           return this;
       }
       
       public List<Customer> Build() {
           return Enumerable.Range(0, _count)
               .Select(i => {
                   var builder = new CustomerBuilder();
                   _configure(builder, i);
                   return builder.Build();
               })
               .ToList();
       }
   }
   
   // Usage
   var customers = new CustomerCollectionBuilder()
       .WithCount(10)
       .Configure((builder, index) => builder.WithId(index + 1))
       .Build();

BOGUS LIBRARY (Alternative):
  // Generate realistic fake data
  dotnet add package Bogus
  
  var faker = new Faker<Customer>()
      .RuleFor(c => c.Id, f => f.IndexFaker)
      .RuleFor(c => c.Name, f => f.Name.FullName())
      .RuleFor(c => c.Email, f => f.Internet.Email())
      .RuleFor(c => c.Phone, f => f.Phone.PhoneNumber())
      .RuleFor(c => c.Address, f => new Address {
          Street = f.Address.StreetAddress(),
          City = f.Address.City(),
          State = f.Address.StateAbbr(),
          ZipCode = f.Address.ZipCode()
      });
  
  var customer = faker.Generate();  // Generate one
  var customers = faker.Generate(100);  // Generate 100

AUTOFIX TURE LIBRARY (Alternative):
  // Auto-generate test data
  dotnet add package AutoFixture
  
  var fixture = new Fixture();
  var customer = fixture.Create<Customer>();  // All properties filled
  var customers = fixture.CreateMany<Customer>(10);

BEST PRACTICES:
  • Use builders for complex objects
  • Provide sensible defaults
  • Make test intent clear (only override what matters)
  • One builder per aggregate root
  • Consider Bogus/AutoFixture for simple scenarios
  • Keep builders in test project
  • Update builders when models change

EXAMPLE FILE: Learning/Testing/TestDataBuilders.cs

-------------------------------------------------------------------------------
9.3.4 INTEGRATION TESTING
-------------------------------------------------------------------------------

PURPOSE:
  Test multiple components working together. More realistic than unit tests
  but slower and more complex.

WEB API INTEGRATION TESTS:
  Installation:
  dotnet add package Microsoft.AspNetCore.Mvc.Testing
  
  Setup:
  public class CustomWebApplicationFactory : WebApplicationFactory<Program> {
      protected override void ConfigureWebHost(IWebHostBuilder builder) {
          builder.ConfigureServices(services => {
              // Remove real database
              var descriptor = services.SingleOrDefault(
                  d => d.ServiceType == typeof(DbContextOptions<AppDbContext>));
              if (descriptor != null) services.Remove(descriptor);
              
              // Add in-memory database
              services.AddDbContext<AppDbContext>(options => {
                  options.UseInMemoryDatabase("TestDb");
              });
              
              // Seed test data
              var sp = services.BuildServiceProvider();
              using var scope = sp.CreateScope();
              var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
              db.Database.EnsureCreated();
              SeedTestData(db);
          });
      }
      
      private void SeedTestData(AppDbContext db) {
          db.Customers.AddRange(
              new Customer { Id = 1, Name = "Test Customer 1" },
              new Customer { Id = 2, Name = "Test Customer 2" }
          );
          db.SaveChanges();
      }
  }
  
  // Test class
  public class OrdersIntegrationTests : IClassFixture<CustomWebApplicationFactory> {
      private readonly HttpClient _client;
      private readonly CustomWebApplicationFactory _factory;
      
      public OrdersIntegrationTests(CustomWebApplicationFactory factory) {
          _factory = factory;
          _client = factory.CreateClient();
      }
      
      [Fact]
      public async Task GetOrders_ReturnsSuccessWithOrders() {
          // Act
          var response = await _client.GetAsync("/api/orders");
          
          // Assert
          response.EnsureSuccessStatusCode();
          var content = await response.Content.ReadFromJsonAsync<List<OrderDto>>();
          Assert.NotNull(content);
          Assert.NotEmpty(content);
      }
      
      [Fact]
      public async Task CreateOrder_ValidRequest_Returns201() {
          // Arrange
          var request = new CreateOrderRequest {
              CustomerId = 1,
              Items = new List<OrderItemRequest> {
                  new() { ProductId = 1, Quantity = 2, Price = 10.00m }
              }
          };
          
          // Act
          var response = await _client.PostAsJsonAsync("/api/orders", request);
          
          // Assert
          Assert.Equal(HttpStatusCode.Created, response.StatusCode);
          var order = await response.Content.ReadFromJsonAsync<OrderDto>();
          Assert.NotNull(order);
          Assert.Equal(1, order.CustomerId);
          
          // Verify location header
          Assert.NotNull(response.Headers.Location);
      }
      
      [Fact]
      public async Task GetOrder_ExistingId_ReturnsOrder() {
          // Arrange - create order first
          var createRequest = new CreateOrderRequest { CustomerId = 1, Items = [...] };
          var createResponse = await _client.PostAsJsonAsync("/api/orders", createRequest);
          var createdOrder = await createResponse.Content.ReadFromJsonAsync<OrderDto>();
          
          // Act - get the order
          var getResponse = await _client.GetAsync($"/api/orders/{createdOrder.Id}");
          
          // Assert
          getResponse.EnsureSuccessStatusCode();
          var order = await getResponse.Content.ReadFromJsonAsync<OrderDto>();
          Assert.Equal(createdOrder.Id, order.Id);
      }
      
      [Fact]
      public async Task DeleteOrder_ExistingId_Returns204() {
          // Arrange
          var createRequest = new CreateOrderRequest { CustomerId = 1, Items = [...] };
          var createResponse = await _client.PostAsJsonAsync("/api/orders", createRequest);
          var createdOrder = await createResponse.Content.ReadFromJsonAsync<OrderDto>();
          
          // Act
          var deleteResponse = await _client.DeleteAsync($"/api/orders/{createdOrder.Id}");
          
          // Assert
          Assert.Equal(HttpStatusCode.NoContent, deleteResponse.StatusCode);
          
          // Verify deleted
          var getResponse = await _client.GetAsync($"/api/orders/{createdOrder.Id}");
          Assert.Equal(HttpStatusCode.NotFound, getResponse.StatusCode);
      }
  }

AUTHENTICATION IN INTEGRATION TESTS:
  // Add test authentication
  builder.ConfigureTestServices(services => {
      services.AddAuthentication("Test")
          .AddScheme<AuthenticationSchemeOptions, TestAuthHandler>("Test", options => { });
  });
  
  // Custom auth handler
  public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions> {
      protected override Task<AuthenticateResult> HandleAuthenticateAsync() {
          var claims = new[] { 
              new Claim(ClaimTypes.Name, "Test User"),
              new Claim(ClaimTypes.NameIdentifier, "1")
          };
          var identity = new ClaimsIdentity(claims, "Test");
          var principal = new ClaimsPrincipal(identity);
          var ticket = new AuthenticationTicket(principal, "Test");
          
          return Task.FromResult(AuthenticateResult.Success(ticket));
      }
  }
  
  // Usage in tests
  _client.DefaultRequestHeaders.Authorization = 
      new AuthenticationHeaderValue("Test");

DATABASE INTEGRATION TESTS:
  public class RepositoryIntegrationTests : IDisposable {
      private readonly AppDbContext _context;
      
      public RepositoryIntegrationTests() {
          var options = new DbContextOptionsBuilder<AppDbContext>()
              .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
              .Options;
          
          _context = new AppDbContext(options);
          _context.Database.EnsureCreated();
      }
      
      [Fact]
      public async Task AddCustomer_ValidCustomer_SavesToDatabase() {
          // Arrange
          var repository = new CustomerRepository(_context);
          var customer = new Customer { Name = "John Doe", Email = "john@example.com" };
          
          // Act
          var result = await repository.AddAsync(customer);
          
          // Assert
          Assert.NotEqual(0, result.Id);
          var saved = await _context.Customers.FindAsync(result.Id);
          Assert.NotNull(saved);
          Assert.Equal("John Doe", saved.Name);
      }
      
      public void Dispose() {
          _context.Database.EnsureDeleted();
          _context.Dispose();
      }
  }

USING REAL DATABASE (SQLite):
  dotnet add package Microsoft.EntityFrameworkCore.Sqlite
  
  var connection = new SqliteConnection("DataSource=:memory:");
  connection.Open();
  
  var options = new DbContextOptionsBuilder<AppDbContext>()
      .UseSqlite(connection)
      .Options;
  
  using var context = new AppDbContext(options);
  context.Database.EnsureCreated();
  // Run tests...
  connection.Close();

RESPAWN LIBRARY (Database cleanup):
  // Reset database between tests
  dotnet add package Respawn
  
  private static Respawner _respawner;
  
  public async Task InitializeAsync() {
      _respawner = await Respawner.CreateAsync(_connectionString);
  }
  
  public async Task ResetDatabase() {
      await _respawner.ResetAsync(_connectionString);
  }

TESTCONTAINERS (Real databases in Docker):
  // Run real SQL Server, PostgreSQL, etc. in Docker
  dotnet add package Testcontainers.MsSql
  
  public class DatabaseFixture : IAsyncLifetime {
      private readonly MsSqlContainer _container = new MsSqlBuilder()
          .WithImage("mcr.microsoft.com/mssql/server:2022-latest")
          .Build();
      
      public string ConnectionString => _container.GetConnectionString();
      
      public async Task InitializeAsync() {
          await _container.StartAsync();
      }
      
      public async Task DisposeAsync() {
          await _container.DisposeAsync();
      }
  }

MESSAGE QUEUE INTEGRATION TESTS:
  // Test with actual message queue or in-memory substitute
  public class MessageQueueTests {
      [Fact]
      public async Task PublishMessage_ValidMessage_ConsumerReceives() {
          // Arrange
          var publisher = new MessagePublisher(_config);
          var consumer = new MessageConsumer(_config);
          var received = false;
          
          consumer.OnMessageReceived += (msg) => received = true;
          await consumer.StartAsync();
          
          // Act
          await publisher.PublishAsync(new OrderCreatedMessage { OrderId = 1 });
          await Task.Delay(1000);  // Wait for async processing
          
          // Assert
          Assert.True(received);
      }
  }

BEST PRACTICES:
  • Use in-memory or containerized databases
  • Isolate tests (each test gets clean state)
  • Test realistic scenarios
  • Don't mock too much (defeats purpose)
  • Run integration tests separately from unit tests
  • Use factories for test setup
  • Clean up resources (IDisposable, IAsyncDisposable)
  • Consider using Respawn or similar for database cleanup

INTEGRATION TEST PROJECT- Structure:
  MyApp.IntegrationTests/
    ├── Fixtures/
    │   ├── WebApplicationFactory.cs
    │   ├── DatabaseFixture.cs
    │   └── TestAuthHandler.cs
    ├── Controllers/
    │   ├── OrdersControllerTests.cs
    │   └── CustomersControllerTests.cs
    ├── Repositories/
    │   └── OrderRepositoryTests.cs
    └── Helpers/
        └── TestDataSeeder.cs

EXAMPLE FILE: Learning/Testing/IntegrationTesting.cs

-------------------------------------------------------------------------------
9.3.5 TESTING ASYNC CODE
-------------------------------------------------------------------------------

ASYNC TEST METHODS:
  // xUnit
  [Fact]
  public async Task GetOrder_ExistingId_ReturnsOrder() {
      var order = await _service.GetOrderAsync(1);
      Assert.NotNull(order);
  }
  
  // NUnit
  [Test]
  public async Task GetOrder_ExistingId_ReturnsOrder() {
      var order = await _service.GetOrderAsync(1);
      Assert.That(order, Is.Not.Null);
  }

TESTING ASYNC EXCEPTIONS:
  // xUnit
  await Assert.ThrowsAsync<OrderNotFoundException>(
      () => _service.GetOrderAsync(999));
  
  // NUnit
  Assert.ThrowsAsync<OrderNotFoundException>(
      async () => await _service.GetOrderAsync(999));

TESTING CANCELLATION:
  [Fact]
  public async Task ProcessOrder_Cancelled_ThrowsOperationCanceledException() {
      // Arrange
      var cts = new CancellationTokenSource();
      cts.Cancel();  // Cancel immediately
      
      // Act & Assert
      await Assert.ThrowsAsync<OperationCanceledException>(
          () => _service.ProcessOrderAsync(1, cts.Token));
  }
  
  [Fact]
  public async Task LongRunningOperation_CancelledMidway_Stops() {
      // Arrange
      var cts = new CancellationTokenSource();
      var task = _service.LongRunningOperationAsync(cts.Token);
      
      // Act
      await Task.Delay(100);  // Let it start
      cts.Cancel();
      
      // Assert
      await Assert.ThrowsAsync<OperationCanceledException>(() => task);
  }

TESTING CONCURRENCY:
  [Fact]
  public async Task ProcessOrders_Concurrent_AllProcessed() {
      // Arrange
      var orders = Enumerable.Range(1, 100).ToList();
      
      // Act
      var tasks = orders.Select(id => _service.ProcessOrderAsync(id));
      await Task.WhenAll(tasks);
      
      // Assert
      var processed = await _repository.GetProcessedCountAsync();
      Assert.Equal(100, processed);
  }

TESTING TIMEOUTS:
  [Fact]
  public async Task SlowOperation_ExceedsTimeout_Throws() {
      // Arrange
      using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1));
      
      // Act & Assert
      await Assert.ThrowsAsync<OperationCanceledException>(
          () => _service.SlowOperationAsync(cts.Token));
  }
  
  // xUnit timeout attribute
  [Fact(Timeout = 5000)]  // 5 seconds
  public async Task Operation_CompletesWithinTimeout() {
      await _service.ProcessAsync();
  }

MOCKING ASYNC METHODS:
  // Setup async method
  mock.Setup(r => r.GetByIdAsync(1))
      .ReturnsAsync(order);
  
  // Or with Task.FromResult
  mock.Setup(r => r.GetByIdAsync(1))
      .Returns(Task.FromResult(order));
  
  // Delay simulation
  mock.Setup(r => r.SlowOperationAsync())
      .Returns(async () => {
          await Task.Delay(1000);
          return result;
      });

TESTING TASK COMPLETION STATES:
  [Fact]
  public async Task GetOrder_Success_TaskCompleted() {
      var task = _service.GetOrderAsync(1);
      var order = await task;
      
      Assert.True(task.IsCompleted);
      Assert.False(task.IsFaulted);
      Assert.False(task.IsCanceled);
  }
  
  [Fact]
  public void GetOrder_Exception_TaskFaulted() {
      mock.Setup(r => r.GetByIdAsync(999))
          .ThrowsAsync(new OrderNotFoundException(999));
      
      var task = _service.GetOrderAsync(999);
      
      var exception = await Assert.ThrowsAsync<OrderNotFoundException>(() => task);
      Assert.True(task.IsFaulted);
  }

AWAITABLE ASSERTIONS:
  // FluentAssertions library
  dotnet add package FluentAssertions
  
  await act.Should().ThrowAsync<OrderNotFoundException>();
  await act.Should().CompleteWithinAsync(TimeSpan.FromSeconds(1));
  
  var task = _service.GetOrderAsync(1);
  await task.Should().Com pleteWithinAsync(TimeSpan.FromSeconds(5));
  task.Result.Should().NotBeNull();

TESTING PARALLEL EXECUTION:
  [Fact]
  public async Task ProcessMultipleOrders_RunsInParallel() {
      // Arrange
      var stopwatch = Stopwatch.StartNew();
      var orders = Enumerable.Range(1, 10).ToList();
      
      // Each takes 1 second
      mock.Setup(r => r.ProcessAsync(It.IsAny<int>()))
          .Returns(async (int id) => {
              await Task.Delay(1000);
              return id;
          });
      
      // Act
      var tasks = orders.Select(id => _service.ProcessOrderAsync(id));
      await Task.WhenAll(tasks);
      stopwatch.Stop();
      
      // Assert - should complete in ~1 second (parallel), not 10 seconds (sequential)
      Assert.True(stopwatch.ElapsedMilliseconds < 2000);
  }

TESTING ASYNC VOID (Event Handlers):
  // Problem: Can't await async void
  public async void Button_Click(object sender, EventArgs e) {
      await ProcessAsync();
  }
  
  // Solution: Use TaskCompletionSource
  [Fact]
  public async Task ButtonClick_ProcessesSuccessfully() {
      var tcs = new TaskCompletionSource<bool>();
      
      // Arrange
      _button.Click += async (s, e) => {
          try {
              await _service.ProcessAsync();
              tcs.SetResult(true);
          }
          catch (Exception ex) {
              tcs.SetException(ex);
          }
      };
      
      // Act
      _button.PerformClick();
      
      // Assert
      var result = await tcs.Task;
      Assert.True(result);
  }

BEST PRACTICES:
  • Always await async methods in tests
  • Test both success and failure paths
  • Test cancellation scenarios
  • Use timeouts to prevent hanging tests
  • Test concurrent execution where applicable
  • Mock async dependencies correctly
  • Be careful with timing-dependent tests
  • Use TaskCompletionSource for async void testing

EXAMPLE FILE: Learning/Testing/AsyncTestingExamples.cs

-------------------------------------------------------------------------------
9.4 PERFORMANCE OPTIMIZATION
-------------------------------------------------------------------------------

DATABASE OPTIMIZATION:
  // BAD: N+1 query problem
  var customers = await dbContext.Customers.ToListAsync();
  foreach (var customer in customers) {
      var orders = await dbContext.Orders
          .Where(o => o.CustomerId == customer.Id)
          .ToListAsync();  // Separate query for each customer!
  }
  
  // GOOD: Single query with Include
  var customers = await dbContext.Customers
      .Include(c => c.Orders)
      .ToListAsync();  // One query with JOIN

ASNOTRACKING:
  // Read-only queries - don't track changes
  var customers = await dbContext.Customers
      .AsNoTracking()
      .ToListAsync();  // Faster, less memory

PROJECTION:
  // BAD: Fetching entire entity when only need few fields
  var customers = await dbContext.Customers.ToListAsync();
  var names = customers.Select(c => c.Name);
  
  // GOOD: Project in database
  var names = await dbContext.Customers
      .Select(c => c.Name)
      .ToListAsync();  // Only fetches Name column

COMPILED QUERIES:
  // For frequently executed queries
  private static readonly Func<AppDbContext, int, Task<Customer?>> GetCustomerById =
      EF.CompileAsyncQuery((AppDbContext db, int id) =>
          db.Customers.FirstOrDefault(c => c.Id == id));
  
  // Usage
  var customer = await GetCustomerById(dbContext, customerId);

CACHING:
  private readonly IMemoryCache _cache;
  
  public async Task<List<Product>> GetProductsAsync() {
      const string cacheKey = "products_all";
      
      if (!_cache.TryGetValue(cacheKey, out List<Product> products)) {
          products = await dbContext.Products.ToListAsync();
          
          var cacheOptions = new MemoryCacheEntryOptions()
              .SetAbsoluteExpiration(TimeSpan.FromMinutes(5));
          
          _cache.Set(cacheKey, products, cacheOptions);
      }
      
      return products;
  }

ASYNC/AWAIT:
  // Free up threads during I/O
  await Task.Delay(100);  // Not: Thread.Sleep(100)
  await httpClient.GetStringAsync(url);  // Not: httpClient.GetString(url).Result

OBJECT POOLING:
  // For frequently created/destroyed objects
  private static readonly ObjectPool<StringBuilder> _pool =
      ObjectPool.Create<StringBuilder>();
  
  public string BuildString() {
      var sb = _pool.Get();
      try {
          sb.Append("Hello ");
          sb.Append("World");
          return sb.ToString();
      }
      finally {
          sb.Clear();
          _pool.Return(sb);
      }
  }

SPAN<T> AND MEMORY<T>:
  // Avoid allocations for slicing
  // BAD: Creates new string
  string sub = text.Substring(0, 10);
  
  // GOOD: No allocation
  ReadOnlySpan<char> span = text.AsSpan(0, 10);

VALUETASK:
  // When result is often synchronous (cached)
  private Dictionary<int, Product> _cache = new();
  
  public ValueTask<Product> GetProductAsync(int id) {
      if (_cache.TryGetValue(id, out var product)) {
          return new ValueTask<Product>(product);  // Synchronous, no allocation
      }
      
      return new ValueTask<Product>(FetchFromDatabaseAsync(id));
  }

BENCHMARKING:
  // Use BenchmarkDotNet for accurate measurements
  [MemoryDiagnoser]
  public class PerformanceBenchmarks {
      [Benchmark]
      public string StringConcat() {
          string result = "";
          for (int i = 0; i < 100; i++)
              result += i.ToString();
          return result;
      }
      
      [Benchmark]
      public string StringBuilder() {
          var sb = new StringBuilder();
          for (int i = 0; i < 100; i++)
              sb.Append(i);
          return sb.ToString();
      }
  }

PROFILING TOOLS:
  • Visual Studio Profiler
  • dotTrace (JetBrains)
  • PerfView (Microsoft)
  • Application Insights
  • MiniProfiler

BEST PRACTICES:
  • Profile before optimizing ("premature optimization is root of all evil")
  • Optimize database queries first (usually biggest impact)
  • Use caching for expensive operations
  • Async/await for I/O-bound operations
  • Reduce allocations in hot paths
  • Use appropriate data structures
  • Lazy loading when appropriate
  • Pagination for large result sets
  • Connection pooling
  • Compression for API responses

EXAMPLE FILE: PracticalExamples/PerformanceOptimization.cs

-------------------------------------------------------------------------------
9.5 SECURITY BEST PRACTICES
-------------------------------------------------------------------------------

AUTHENTICATION & AUTHORIZATION:
  // JWT Authentication
  builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
      .AddJwtBearer(options => {
          options.TokenValidationParameters = new TokenValidationParameters {
              ValidateIssuer = true,
              ValidateAudience = true,
              ValidateLifetime = true,
              ValidateIssuerSigningKey = true,
              ValidIssuer = config["Jwt:Issuer"],
              ValidAudience = config["Jwt:Audience"],
              IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(config["Jwt:Key"]))
          };
      });
  
  builder.Services.AddAuthorization(options => {
      options.AddPolicy("AdminOnly", policy => policy.RequireRole("Admin"));
      options.AddPolicy("CanEditOrders", policy => policy.RequireClaim("Permission", "Orders.Edit"));
  });
  
  // Usage
  [Authorize]
  public class OrdersController : ControllerBase {
      [Authorize(Policy = "AdminOnly")]
      [HttpDelete("{id}")]
      public async Task<IActionResult> Delete(int id) { }
  }

INPUT VALIDATION:
  // Always validate input
  public class CreateUserRequest {
      [Required]
      [StringLength(100, MinimumLength = 3)]
      public string Username { get; set; }
      
      [Required]
      [EmailAddress]
      public string Email { get; set; }
      
      [Required]
      [StringLength(100, MinimumLength = 8)]
      [RegularExpression(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).+$")]
      public string Password { get; set; }
  }

SQL INJECTION PREVENTION:
  // BAD: Vulnerable to SQL injection
  string sql = $"SELECT * FROM Users WHERE Username = '{username}'";
  
  // GOOD: Parameterized query
  var users = await dbContext.Users
      .Where(u => u.Username == username)
      .ToListAsync();
  
  // Or with ADO.NET
  command.CommandText = "SELECT * FROM Users WHERE Username = @username";
  command.Parameters.AddWithValue("@username", username);

XSS PREVENTION:
  // Razor automatically HTML-encodes output
  <div>@Model.UserInput</div>  // Safe - encoded
  
  // If you need raw HTML (be very careful!)
  <div>@Html.Raw(Model.TrustedContent)</div>
  
  // Sanitize user input
  string sanitized = WebUtility.HtmlEncode(userInput);

CORS:
  builder.Services.AddCors(options => {
      options.AddPolicy("AllowSpecificOrigin", policy => {
          policy.WithOrigins("https://example.com")
                .WithMethods("GET", "POST")
                .WithHeaders("Authorization", "Content-Type");
      });
  });
  
  app.UseCors("AllowSpecificOrigin");

SECRETS MANAGEMENT:
  // DON'T commit secrets to source control
  // Use User Secrets for development
  // Use Azure Key Vault, AWS Secrets Manager, etc. for production
  
  // User Secrets (development)
  dotnet user-secrets set "ApiKey" "secret123"
  
  // Azure Key Vault (production)
  builder.Configuration.AddAzureKeyVault(
      new Uri(builder.Configuration["KeyVault:Uri"]),
      new DefaultAzureCredential());

PASSWORD HASHING:
  // Use ASP.NET Core Identity's password hasher
  private readonly IPasswordHasher<User> _hasher = new PasswordHasher<User>();
  
  // Hash password
  string hashed = _hasher.HashPassword(user, "password123");
  
  // Verify password
  var result = _hasher.VerifyHashedPassword(user, hashed, "password123");
  
  // Or use BCrypt
  string hashed = BCrypt.Net.BCrypt.HashPassword("password123");
  bool verified = BCrypt.Net.BCrypt.Verify("password123", hashed);

HTTPS ENFORCEMENT:
  // Redirect HTTP to HTTPS
  app.UseHttpsRedirection();
  
  // HSTS (HTTP Strict Transport Security)
  app.UseHsts();  // Tells browsers to only use HTTPS

RATE LIMITING:
  builder.Services.AddRateLimiter(options => {
      options.AddFixedWindowLimiter("fixed", options => {
          options.Window = TimeSpan.FromSeconds(10);
          options.PermitLimit = 100;
      });
  });
  
  app.UseRateLimiter();
  
  [EnableRateLimiting("fixed")]
  [HttpGet]
  public IActionResult Get() { }

BEST PRACTICES CHECKLIST:
  ✅ Use HTTPS everywhere
  ✅ Validate and sanitize all input
  ✅ Use parameterized queries (prevent SQL injection)
  ✅ Hash passwords (never store plain text)
  ✅ Implement authentication & authorization
  ✅ Use secure headers (HSTS, CSP, X-Frame-Options)
  ✅ Protect against XSS (encode output)
  ✅ Protect against CSRF
  ✅ Rate limiting
  ✅ Keep dependencies updated
  ✅ Don't expose sensitive data in errors
  ✅ Use secrets management
  ✅ Logging (but not sensitive data)
  ✅ Regular security audits

EXAMPLE FILE: PracticalExamples/SecurityBestPractices.cs

-------------------------------------------------------------------------------
9.6 CODE REVIEW GUIDELINES
-------------------------------------------------------------------------------

WHAT TO LOOK FOR:

FUNCTIONALITY:
  ✅ Does the code do what it's supposed to?
  ✅ Are edge cases handled?
  ✅ Are errors handled appropriately?

CODE QUALITY:
  ✅ Is it readable?
  ✅ Are names descriptive?
  ✅ Is it DRY (not repetitive)?
  ✅ Is it KISS (not over-complicated)?
  ✅ Does it follow SOLID principles?

PERFORMANCE:
  ✅ Any obvious performance issues?
  ✅ Appropriate use of async/await?
  ✅ Database queries optimized?
  ✅ Unnecessary allocations?

SECURITY:
  ✅ Input validation?
  ✅ SQL injection risks?
  ✅ XSS vulnerabilities?
  ✅ Authentication/authorization?
  ✅ Secrets in code?

TESTING:
  ✅ Are there tests?
  ✅ Do tests cover edge cases?
  ✅ Are tests meaningful?

MAINTAINABILITY:
  ✅ Would I understand this in 6 months?
  ✅ Is it well-documented (if complex)?
  ✅ Consistent with codebase style?

HOW TO GIVE FEEDBACK:
  • Be constructive, not critical
  • Explain the "why", not just the "what"
  • Suggest alternatives
  • Ask questions instead of making demands
  • Praise good code
  • Be respectful

GOOD FEEDBACK EXAMPLES:
  ✅ "Consider extracting this logic into a separate method for better testability."
  ✅ "This could be vulnerable to SQL injection. Have you considered using parameterized queries?"
  ✅ "Great use of the Strategy pattern here!"
  ✅ "This method is doing a lot. What do you think about splitting it according to SRP?"

BAD FEEDBACK EXAMPLES:
  ❌ "This is wrong."
  ❌ "Why did you do it this way?"
  ❌ "Change this."

AUTOMATED CHECKS:
  • Linting (StyleCop, Roslynator)
  • Code coverage
  • Security scanning (SonarQube)
  • Static analysis

===============================================================================
END OF COMPREHENSIVE REVISION NOTES
===============================================================================

This document provides comprehensive coverage of:
  • SOLID Principles (5 principles)
  • Core OOP Principles (4 principles: KISS, DRY, YAGNI, TDA)
  • Design Patterns (21 patterns: 5 creational, 6 structural, 6 behavioral + CQRS)
  • Memory Management (4 topics)
  • Async & Multithreading (4 topics)
  • .NET Framework Concepts (9 base topics)
    - Entity Framework Core (expanded with 5 detailed sub-topics):
      * Change Tracking
      * Relationships & Navigation Properties
      * Migrations in Depth
      * Performance Optimization
      * Best Practices & Anti-Patterns ⭐ NEW
  • Practical Examples & Best Practices (6 base topics)
    - Testing Best Practices (expanded with 5 detailed sub-topics):
      * Testing Frameworks (xUnit, NUnit, MSTest)
      * Mocking in Depth
      * Test Data Builders
      * Integration Testing
      * Testing Async Code

For complete working code examples of every concept, refer to:
c:\Users\barry\OneDrive\LearningProjects\RevisionNotes\RevisionNotesDemo

All 55+ implementation files contain comprehensive header comments matching
this documentation.

Total Concepts Covered: 66+
Total Sections: 9 major parts with 19 expanded sub-sections
Documentation Level: Comprehensive Professional Reference
Lines of Documentation: 7,100+
Last Updated: February 13, 2025
Version: 3.1 - Enhanced Entity Framework Core with Best Practices & Anti-Patterns
Author: Barry




